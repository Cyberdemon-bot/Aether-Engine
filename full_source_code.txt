
====================
FILE: ./xmake.lua
====================
set_project("AetherWorkspace")
set_version("1.0.0")

add_rules("mode.debug", "mode.release")
set_languages("c++17")

includes("Aether")

target("Sandbox")
    set_kind("binary") 
    set_rundir("$(projectdir)/Sandbox") 
    
    add_files("Sandbox/src/**.cpp")

    add_deps("Aether")
====================
FILE: ./Aether/xmake.lua
====================
includes("packages/*.lua")

add_requires("spdlog", "fmt", "glm", "entt", "yaml-cpp", "glfw")
add_requires("imgui v1.89.9-docking", {configs = {glfw_opengl3 = true}})
add_requires("imguizmo", {configs = {imgui = "imgui"}})
add_requires("box2d v3.1.1", "stb", "freetype")
add_requires("filewatch", "msdf-atlas-gen", "glad")

target("Aether")
    set_kind("shared")
    add_defines("AETHER_BUILD_DLL")
    add_defines("MSDFGEN_USE_CPP11", "MSDFGEN_EXTENSIONS")

    if is_mode("debug") then
        add_defines("AETHER_DEBUG", {public = true})
        add_symbols("debug")
        set_policy("build.sanitizer.address", true)
    end

    add_includedirs("src", {public = true})
    add_includedirs("vendor", {public = true})

    add_files("src/**.cpp")
    add_headerfiles("src/**.h")
    
    set_pcxxheader("src/aepch.h")

    add_packages("spdlog", "fmt", "glm", "entt", "yaml-cpp", "glfw", "imgui", "stb", "imguizmo", "freetype", "box2d", {public = true})
    add_packages("filewatch", "msdf-atlas-gen", "glad", {public = true})

    if is_os("windows") then
        add_syslinks("opengl32")
    elseif is_os("macosx") then
        add_frameworks("OpenGL", "Cocoa", "IOKit", "CoreVideo")
    elseif is_os("linux") then
        add_syslinks("pthread", "dl")
    end
====================
FILE: ./Aether/packages/filewatch.lua
====================
package("filewatch")
    set_kind("library", {headeronly = true})
    set_homepage("https://github.com/ThomasMonkman/filewatch")
    set_description("C++11 cross-platform file watching")
    set_urls("https://github.com/ThomasMonkman/filewatch.git")

    on_install(function (package)
        os.cp("FileWatch.hpp", package:installdir("include"))
    end)
====================
FILE: ./Aether/packages/glad.lua
====================
package("glad")
    set_kind("library", {headeronly = false})
    set_description("Local Glad OpenGL loader")

    on_install(function (package)
        import("package.tools.xmake")

        local project_dir = os.workingdir()
        local local_glad_src = path.join(project_dir, "Aether/vendor/glad/src/glad.c")
        local local_glad_inc = path.join(project_dir, "Aether/vendor/glad/include")

        if not os.isfile(local_glad_src) then
            raise("GLAD ERROR: Cannot find out files at " .. local_glad_src)
        end

        os.cp(local_glad_src, "src/glad.c")
        os.cp(local_glad_inc, "include")
        os.cp(path.join(local_glad_inc, "*"), package:installdir("include"))

        local xmake_lua = [[
            target("glad")
                set_kind("static")
                add_files("src/glad.c")
                add_includedirs("include") 
                add_includedirs("include", {public = true})
        ]]
        io.writefile("xmake.lua", xmake_lua)

        -- 4. Build lib
        xmake.install(package)
    end)
====================
FILE: ./Aether/packages/msdf-atlas-gen.lua
====================
package("msdf-atlas-gen")
    set_homepage("https://github.com/Chlumsky/msdf-atlas-gen")
    set_description("MSDF atlas generator (Native xmake build)")
    set_urls("https://github.com/Chlumsky/msdf-atlas-gen.git")

    add_deps("freetype")

    on_install(function (package)
        io.writefile("msdfgen/msdfgen-config.h", [[
            #pragma once
            #define MSDFGEN_PUBLIC
            #define MSDFGEN_VERSION "1.10.0"
        ]])

        local xmake_script = [[
            add_rules("mode.release", "mode.debug")
            add_requires("freetype")

            target("msdf-atlas-gen")
                set_kind("static")
                set_languages("c++17") 
                add_defines("MSDFGEN_USE_CPP11", "MSDFGEN_EXTENSIONS")
                add_defines("MSDFGEN_DISABLE_SVG") 
                add_includedirs(".", "msdfgen", {public = true})
                add_files("msdf-atlas-gen/*.cpp")
                add_files("msdfgen/core/*.cpp")
                add_files("msdfgen/ext/*.cpp")
                remove_files("msdfgen/ext/import-font.cpp") 
                remove_files("msdf-atlas-gen/artery-font-export.cpp") -- File này cần lib ngoài, bỏ đi cho nhẹ
                remove_files("msdfgen/main.cpp")
                
                add_packages("freetype")
        ]]
        
        io.writefile("xmake.lua", xmake_script)

        -- BƯỚC 3: Build
        import("package.tools.xmake").install(package)
    end)
====================
FILE: ./Aether/src/Aether.h
====================
#pragma once

#include "Aether/Core/Application.h"
#include "Aether/Core/Layer.h"
#include "Aether/Core/Log.h"
#include "Aether/Core/EntryPoint.h"

#include "Aether/Core/Timestep.h"

#include "Aether/Core/Input.h"
#include "Aether/Core/KeyCodes.h"
#include "Aether/Core/MouseCodes.h"

#include "Aether/ImGui/ImGuiLayer.h"

#include "Aether/Renderer/RenderCommand.h"
#include "Aether/Renderer/Legacy/LegacyAPI.h"
====================
FILE: ./Aether/src/aepch.h
====================
#pragma once

#include <iostream>
#include <memory>
#include <utility>
#include <algorithm>
#include <functional>
#include <string>
#include <vector>

#include <spdlog/spdlog.h>
#include <spdlog/fmt/ostr.h>
#include <glad/glad.h> 
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>

#include "Aether/Core/Base.h"
#include "Aether/Core/Log.h"
====================
FILE: ./Aether/src/aepch.cpp
====================
#include "aepch.h"
====================
FILE: ./Aether/src/Platform/GLFW/GLFW_Window.cpp
====================
#include "aepch.h"
#include "Platform/GLFW/GLFW_Window.h"

#include "Aether/Core/Input.h"

#include "Aether/Events/ApplicationEvent.h"
#include "Aether/Events/MouseEvent.h"
#include "Aether/Events/KeyEvent.h"

namespace Aether {
	
	static uint8_t s_GLFWWindowCount = 0;

	static void GLFWErrorCallback(int error, const char* description)
	{
		AE_CORE_ERROR("GLFW Error ({0}): {1}", error, description);
	}

	GLFW_Window::GLFW_Window(const WinProps& props) { Init(props); }

	GLFW_Window::~GLFW_Window() { Shutdown(); }

	void GLFW_Window::Init(const WinProps& props)
	{
		m_Data.Title = props.Title;
		m_Data.Width = props.Width;
		m_Data.Height = props.Height;

		AE_CORE_INFO("Creating window {0} ({1}, {2})", props.Title, props.Width, props.Height);

		if (s_GLFWWindowCount == 0)
		{
			int success = glfwInit();
			AE_CORE_ASSERT(success, "Could not initialize GLFW!");
			glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
			glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
			glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);
			glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);
			glfwSetErrorCallback(GLFWErrorCallback);
		}

		m_Window = glfwCreateWindow((int)props.Width, (int)props.Height, m_Data.Title.c_str(), nullptr, nullptr);
	    ++s_GLFWWindowCount;

		int fbWidth, fbHeight;
		glfwGetFramebufferSize(m_Window, &fbWidth, &fbHeight);
		m_Data.FramebufferWidth = fbWidth;
		m_Data.FramebufferHeight = fbHeight;

		AE_CORE_INFO("Window: {0}x{1}, Framebuffer: {2}x{3}", m_Data.Width, m_Data.Height, fbWidth, fbHeight);

		m_Context = GraphicsContext::Create(m_Window);
		m_Context->Init();

		glfwSetWindowUserPointer(m_Window, &m_Data);
		//SetVSync(true);

		// Set GLFW callbacks
		glfwSetWindowSizeCallback(m_Window, [](GLFWwindow* window, int width, int height)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);
			data.Width = width;
			data.Height = height;

    
			// Update framebuffer size too
			int fbWidth, fbHeight;
			glfwGetFramebufferSize(window, &fbWidth, &fbHeight);
			data.FramebufferWidth = fbWidth;
			data.FramebufferHeight = fbHeight;

			WindowResizeEvent event(width, height);
			data.EventCallback(event);
		});

		glfwSetWindowCloseCallback(m_Window, [](GLFWwindow* window)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);
			WindowCloseEvent event;
			data.EventCallback(event);
		});

		glfwSetKeyCallback(m_Window, [](GLFWwindow* window, int key, int scancode, int action, int mods)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			switch (action)
			{
				case GLFW_PRESS:
				{
					KeyPressedEvent event(key, 0);
					data.EventCallback(event);
					break;
				}
				case GLFW_RELEASE:
				{
					KeyReleasedEvent event(key);
					data.EventCallback(event);
					break;
				}
				case GLFW_REPEAT:
				{
					KeyPressedEvent event(key, true);
					data.EventCallback(event);
					break;
				}
			}
		});

		glfwSetCharCallback(m_Window, [](GLFWwindow* window, unsigned int keycode)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			KeyTypedEvent event(keycode);
			data.EventCallback(event);
		});

		glfwSetMouseButtonCallback(m_Window, [](GLFWwindow* window, int button, int action, int mods)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			switch (action)
			{
				case GLFW_PRESS:
				{
					MouseButtonPressedEvent event(button);
					data.EventCallback(event);
					break;
				}
				case GLFW_RELEASE:
				{
					MouseButtonReleasedEvent event(button);
					data.EventCallback(event);
					break;
				}
			}
		});

		glfwSetScrollCallback(m_Window, [](GLFWwindow* window, double xOffset, double yOffset)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			MouseScrolledEvent event((float)xOffset, (float)yOffset);
			data.EventCallback(event);
		});

		glfwSetCursorPosCallback(m_Window, [](GLFWwindow* window, double xPos, double yPos)
		{
			WindowData& data = *(WindowData*)glfwGetWindowUserPointer(window);

			MouseMovedEvent event((float)xPos, (float)yPos);
			data.EventCallback(event);
		});
	}

	void GLFW_Window::Shutdown()
	{
		glfwDestroyWindow(m_Window);
		--s_GLFWWindowCount;

		if (s_GLFWWindowCount == 0) glfwTerminate();
	}

	void GLFW_Window::Update()
	{
		glfwPollEvents();
		m_Context->SwapBuffers();
	}

	void GLFW_Window::SetVSync(bool enabled)
	{
		if (enabled)
			glfwSwapInterval(1);
		else
			glfwSwapInterval(0);

		m_Data.VSync = enabled;
	}

	bool GLFW_Window::IsVSync() const
	{
		return m_Data.VSync;
	}

}

====================
FILE: ./Aether/src/Platform/GLFW/GLFW_Input.cpp
====================
#include "aepch.h"
#include "Aether/Core/Input.h"

#include "Aether/Core/Application.h"
#include <GLFW/glfw3.h>

namespace Aether {

	bool Input::IsKeyPressed(const KeyCode key)
	{
		auto* window = static_cast<GLFWwindow*>(Application::Get().GetWindow().GetWindow());
		auto state = glfwGetKey(window, static_cast<int32_t>(key));
		return state == GLFW_PRESS;
	}

	void Input::SetCursorMode(CursorMode mode)
    {
        auto* window = static_cast<GLFWwindow*>(Application::Get().GetWindow().GetWindow());
        switch (mode)
        {
            case CursorMode::Normal:
                glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
                break;
            case CursorMode::Hidden:
                glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);
                break;
            case CursorMode::Locked:
                glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
                break;
        }
    }

	bool Input::IsMouseButtonPressed(const MouseCode button)
	{
		auto* window = static_cast<GLFWwindow*>(Application::Get().GetWindow().GetWindow());
		auto state = glfwGetMouseButton(window, static_cast<int32_t>(button));
		return state == GLFW_PRESS;
	}

	glm::vec2 Input::GetMousePosition()
	{
		auto* window = static_cast<GLFWwindow*>(Application::Get().GetWindow().GetWindow());
		double xpos, ypos;
		glfwGetCursorPos(window, &xpos, &ypos);

		return { (float)xpos, (float)ypos };
	}

	float Input::GetMouseX()
	{
		return GetMousePosition().x;
	}

	float Input::GetMouseY()
	{
		return GetMousePosition().y;
	}

}
====================
FILE: ./Aether/src/Platform/GLFW/GLFW_PlatformUtils.cpp
====================
#include "aepch.h"
#include "Aether/Utils/PlatformUtils.h"
#include "Aether/Core/Application.h"

#include <GLFW/glfw3.h>

namespace Aether {

	float Time::GetTime()
	{
		return glfwGetTime();
	}


	std::string FileDialogs::OpenFile(const char* filter)
	{
		return "";
	}

	std::string FileDialogs::SaveFile(const char* filter)
	{
		return "";
	}

}

====================
FILE: ./Aether/src/Platform/GLFW/GLFW_Window.h
====================
#pragma once

#include "Aether/Core/Window.h"
#include "Aether/Renderer/GraphicsContext.h"
#include <GLFW/glfw3.h>

namespace Aether {

	class GLFW_Window : public Window
	{
	public:
		GLFW_Window(const WinProps& props);
		virtual ~GLFW_Window();

		void Update() override;

		unsigned int GetWidth() const override { return m_Data.Width; }
		unsigned int GetHeight() const override { return m_Data.Height; }

		unsigned int GetFramebufferWidth() const { return m_Data.FramebufferWidth; }
		unsigned int GetFramebufferHeight() const { return m_Data.FramebufferHeight; }

		// Window attributes
		void SetEventCallback(const EventCallbackFn& callback) override { m_Data.EventCallback = callback; }
		void SetVSync(bool enabled) override;
		bool IsVSync() const override;

		virtual void* GetWindow() const override { return m_Window; }
	private:
		virtual void Init(const WinProps& props);
		virtual void Shutdown();
	private:
		GLFWwindow* m_Window;
		Scope<GraphicsContext> m_Context;

		struct WindowData
		{
			std::string Title;
			unsigned int Width, Height;
			unsigned int FramebufferWidth, FramebufferHeight;
			bool VSync;

			EventCallbackFn EventCallback;
		};

		WindowData m_Data;
	};

}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/VertexBuffer.cpp
====================
#include "VertexBuffer.h"
#include "Renderer.h"

namespace Aether::Legacy { 
    VertexBuffer::VertexBuffer(const void* data, unsigned int size)
    {
        GLCall(glGenBuffers(1, &m_RendererID));
        GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RendererID));
        GLCall(glBufferData(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW));
    }

    VertexBuffer::~VertexBuffer()
    {
        GLCall(glDeleteBuffers(1, &m_RendererID));
    }

    void VertexBuffer::Bind() const
    {
        GLCall(glBindBuffer(GL_ARRAY_BUFFER, m_RendererID));
    }

    void VertexBuffer::Unbind() const
    {
        GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
    }
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/IndexBuffer.h
====================
#pragma once

namespace Aether::Legacy {
    class AETHER_API IndexBuffer
    {
    private:
        unsigned int m_RendererID;
        unsigned int m_Count;
    public:
        IndexBuffer(const unsigned int* data, unsigned int count);
        ~IndexBuffer();

        void Bind() const;
        void Unbind() const;

        inline unsigned int GetCount() const { return m_Count; }
    };
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/Shader.h
====================
#pragma once

#include <string>
#include <unordered_map>

#include "glm/glm.hpp"

namespace Aether::Legacy {
    struct ShaderProgramSource
    {
        std::string VertexSource;
        std::string FragmentSource;
    };

    class AETHER_API Shader
    {
    private:
        std::string m_FilePath;
        unsigned int m_RendererID;  
        std::unordered_map<std::string, int> m_UniformLocationCache;

        int GetUniformLocation(const std::string& name);
        unsigned int CompileShader(unsigned int type, const std::string& source);
        unsigned int CreateShader(const std::string& vertexShader, const std::string& fragmentShader);
        ShaderProgramSource ParseShader(const std::string& filepath);

    public:
        Shader(const std::string& filepath);
        ~Shader();

        void Bind() const;
        void Unbind() const;

        void SetUniform4f(const std::string& name, float v0, float v1, float v2, float v3);
        void SetUniform3f(const std::string& name, const glm::vec3& value);
        void SetUniform1f(const std::string& name, float value);
        void SetUniform1i(const std::string& name, int value);
        void SetUniformMat4f(const std::string& name, const glm::mat4& matrix);
        void SetUniformMat4fv(const std::string& name, unsigned int count, const float* value);
    };
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/VertexArray.cpp
====================
#include "VertexArray.h"
#include "VertexBufferLayout.h"

namespace Aether::Legacy { 
    VertexArray::VertexArray()
    {
        GLCall(glGenVertexArrays(1, &m_RendererID));
    }

    VertexArray::~VertexArray()
    {
        GLCall(glDeleteVertexArrays(1, &m_RendererID));
    }

    void VertexArray::Bind() const
    {
        GLCall(glBindVertexArray(m_RendererID));
    }

    void VertexArray::Unbind() const
    {
        GLCall(glBindVertexArray(0));
    }

    void VertexArray::AddBuffer(const VertexBuffer& vb, const VertexBufferLayout& layout)
    {
        Bind();
        vb.Bind();
        const auto& elements = layout.GetElements();
        unsigned int offset = 0;
        for (unsigned int i = 0; i < elements.size(); i++)
        {
            const auto& element = elements[i];
            GLCall(glEnableVertexAttribArray(i));
            GLCall(glVertexAttribPointer(i, element.count, element.type, element.normalized, layout.GetStride(), (const void*)(uintptr_t)offset));
            offset += element.count * VertexBufferElement::GetSizeOfType(element.type);
        }
        
    }
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/FrameBuffer.cpp
====================
#include "Renderer.h"
#include "FrameBuffer.h"

namespace Aether::Legacy {

	static const uint32_t s_MaxFramebufferSize = 8192;

	namespace Utils {

		static GLenum TextureTarget(bool multisampled)
		{
			return multisampled ? GL_TEXTURE_2D_MULTISAMPLE : GL_TEXTURE_2D;
		}

		static void CreateTextures(bool multisampled, uint32_t* outID, uint32_t count)
		{
			glGenTextures(count, outID);
		}

		static void BindTexture(bool multisampled, uint32_t id)
		{
			glBindTexture(TextureTarget(multisampled), id);
		}

		static void AttachColorTexture(uint32_t id, int samples, GLenum internalFormat, GLenum format, uint32_t width, uint32_t height, int index)
		{
			bool multisampled = samples > 1;
			if (multisampled)
			{
				glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, internalFormat, width, height, GL_FALSE);
			}
			else
			{
				GLenum type = (internalFormat == GL_R32I) ? GL_INT : GL_UNSIGNED_BYTE;

				glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, nullptr);

				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
			}

			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + index, TextureTarget(multisampled), id, 0);
		}

		static void AttachDepthTexture(uint32_t id, int samples, GLenum format, GLenum attachmentType, uint32_t width, uint32_t height)
		{
			bool multisampled = samples > 1;
			if (multisampled)
			{
				glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, format, width, height, GL_FALSE);
			}
			else
			{
				glTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, nullptr);

				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
				glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
			}

			glFramebufferTexture2D(GL_FRAMEBUFFER, attachmentType, TextureTarget(multisampled), id, 0);
		}

		static bool IsDepthFormat(FramebufferTextureFormat format)
		{
			switch (format)
			{
				case FramebufferTextureFormat::DEPTH24STENCIL8:  return true;
                default: return false;
			}
			return false;
		}

		static GLenum TextureFormatToGL(FramebufferTextureFormat format)
		{
			switch (format)
			{
				case FramebufferTextureFormat::RGBA8:       return GL_RGBA8;
				case FramebufferTextureFormat::RED_INTEGER: return GL_RED_INTEGER;
                case FramebufferTextureFormat::DEPTH24STENCIL8: return GL_DEPTH24_STENCIL8;
                case FramebufferTextureFormat::None:        return 0;
			}
			AE_CORE_ASSERT(false);
			return 0;
		}
	}

	FrameBuffer::FrameBuffer(const FramebufferSpecification& spec)
		: m_Specification(spec)
	{
		for (auto spec : m_Specification.Attachments.Attachments)
		{
			if (!Utils::IsDepthFormat(spec.TextureFormat))
				m_ColorAttachmentSpecifications.emplace_back(spec);
			else
				m_DepthAttachmentSpecification = spec;
		}

		Invalidate();
	}

	FrameBuffer::~FrameBuffer()
	{
		glDeleteFramebuffers(1, &m_RendererID);
		glDeleteTextures(m_ColorAttachments.size(), m_ColorAttachments.data());
		glDeleteTextures(1, &m_DepthAttachment);
	}

    void FrameBuffer::BindDepthTexture(uint32_t slot) const
    {
        glActiveTexture(GL_TEXTURE0 + slot);
        glBindTexture(GL_TEXTURE_2D, m_DepthAttachment);
    }

	void FrameBuffer::Invalidate()
	{
		if (m_RendererID)
		{
			glDeleteFramebuffers(1, &m_RendererID);
			glDeleteTextures(m_ColorAttachments.size(), m_ColorAttachments.data());
			glDeleteTextures(1, &m_DepthAttachment);
			
			m_ColorAttachments.clear();
			m_DepthAttachment = 0;
		}

		glGenFramebuffers(1, &m_RendererID);
		glBindFramebuffer(GL_FRAMEBUFFER, m_RendererID);

		bool multisample = m_Specification.Samples > 1;

		if (m_ColorAttachmentSpecifications.size())
		{
			m_ColorAttachments.resize(m_ColorAttachmentSpecifications.size());
			Utils::CreateTextures(multisample, m_ColorAttachments.data(), m_ColorAttachments.size());

			for (size_t i = 0; i < m_ColorAttachments.size(); i++)
			{
				Utils::BindTexture(multisample, m_ColorAttachments[i]);
				switch (m_ColorAttachmentSpecifications[i].TextureFormat)
				{
					case FramebufferTextureFormat::RGBA8:
						Utils::AttachColorTexture(m_ColorAttachments[i], m_Specification.Samples, GL_RGBA8, GL_RGBA, m_Specification.Width, m_Specification.Height, i);
						break;
					case FramebufferTextureFormat::RED_INTEGER:
						Utils::AttachColorTexture(m_ColorAttachments[i], m_Specification.Samples, GL_R32I, GL_RED_INTEGER, m_Specification.Width, m_Specification.Height, i);
						break;

                    case FramebufferTextureFormat::DEPTH24STENCIL8:
                    case FramebufferTextureFormat::None:
                        break;
				}
			}
		}

		if (m_DepthAttachmentSpecification.TextureFormat != FramebufferTextureFormat::None)
		{
			Utils::CreateTextures(multisample, &m_DepthAttachment, 1);
			Utils::BindTexture(multisample, m_DepthAttachment);
			switch (m_DepthAttachmentSpecification.TextureFormat)
			{
				case FramebufferTextureFormat::DEPTH24STENCIL8:
					Utils::AttachDepthTexture(m_DepthAttachment, m_Specification.Samples, GL_DEPTH24_STENCIL8, GL_DEPTH_STENCIL_ATTACHMENT, m_Specification.Width, m_Specification.Height);
					break;
                case FramebufferTextureFormat::RGBA8:
                case FramebufferTextureFormat::RED_INTEGER:
                case FramebufferTextureFormat::None:
                    break;
			}
		}

		if (m_ColorAttachments.size() > 1)
		{
			AE_CORE_ASSERT(m_ColorAttachments.size() <= 4);
			GLenum buffers[4] = { GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1, GL_COLOR_ATTACHMENT2, GL_COLOR_ATTACHMENT3 };
			glDrawBuffers(m_ColorAttachments.size(), buffers);
		}
		else if (m_ColorAttachments.empty())
		{
            glDrawBuffer(GL_NONE);
            glReadBuffer(GL_NONE);
		}

		AE_CORE_ASSERT(glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE, "Framebuffer is incomplete!");

		glBindFramebuffer(GL_FRAMEBUFFER, 0);
	}

	void FrameBuffer::Bind()
	{
		glBindFramebuffer(GL_FRAMEBUFFER, m_RendererID);
		glViewport(0, 0, m_Specification.Width, m_Specification.Height);
	}

	void FrameBuffer::Unbind()
	{
		glBindFramebuffer(GL_FRAMEBUFFER, 0);
	}

	void FrameBuffer::Resize(uint32_t width, uint32_t height)
	{
		if (width == 0 || height == 0 || width > s_MaxFramebufferSize || height > s_MaxFramebufferSize)
		{
			AE_CORE_WARN("Attempted to rezize framebuffer to {0}, {1}", width, height);
			return;
		}
		m_Specification.Width = width;
		m_Specification.Height = height;
		
		Invalidate();
	}

	int FrameBuffer::ReadPixel(uint32_t attachmentIndex, int x, int y)
	{
		AE_CORE_ASSERT(attachmentIndex < m_ColorAttachments.size());

		GLint lastReadBuffer;
		glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING, &lastReadBuffer);

		glBindFramebuffer(GL_READ_FRAMEBUFFER, m_RendererID);
		glReadBuffer(GL_COLOR_ATTACHMENT0 + attachmentIndex);
		
		int pixelData;
		glReadPixels(x, y, 1, 1, GL_RED_INTEGER, GL_INT, &pixelData);
		
		glBindFramebuffer(GL_READ_FRAMEBUFFER, lastReadBuffer);
		return pixelData;
	}

	void FrameBuffer::ClearAttachment(uint32_t attachmentIndex, int value)
	{
		AE_CORE_ASSERT(attachmentIndex < m_ColorAttachments.size());

		GLint lastDrawFramebuffer;
		glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &lastDrawFramebuffer);

		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_RendererID);
		
		glClearBufferiv(GL_COLOR, attachmentIndex, &value);

		glBindFramebuffer(GL_DRAW_FRAMEBUFFER, lastDrawFramebuffer);
	}

}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/Renderer.h
====================
#pragma once

#include <glad/glad.h>
#include "VertexArray.h"
#include "IndexBuffer.h"
#include "Shader.h"

#if defined(_MSC_VER)
    #define DEBUG_BREAK() __debugbreak()
#elif defined(__clang__)
    #define DEBUG_BREAK() __builtin_debugtrap()
#endif

#define ASSERT(x) if (!(x)) DEBUG_BREAK();
#define GLCall(x) GLClearError(); x; ASSERT(GLLogCall(#x, __FILE__, __LINE__));

namespace Aether::Legacy {
    
    void GLClearError();
    bool GLLogCall(const char* function, const char* file, int line);

    class AETHER_API Renderer
    {
    public:
        void Draw(const VertexArray& va, const IndexBuffer& ib, const Shader& shader) const;

        void Clear();
    };
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/Texture.cpp
====================
#define STB_IMAGE_IMPLEMENTATION
#include "Texture.h"
#include <stb_image.h>

namespace Aether::Legacy {
    Texture::Texture(const std::string& path)
        : m_RendererID(0), m_FilePath(path), m_LocalBuffer(nullptr), m_Width(0), m_Height(0), m_BPP(0)
    {
        stbi_set_flip_vertically_on_load(1);
        m_LocalBuffer = stbi_load(path.c_str(), &m_Width, &m_Height, &m_BPP, 4);

        GLCall(glGenTextures(1, &m_RendererID));
        GLCall(glBindTexture(GL_TEXTURE_2D, m_RendererID));

        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE));

        GLCall(glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, m_Width, m_Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer));
        GLCall(glBindTexture(GL_TEXTURE_2D, 0));

        if (m_LocalBuffer) stbi_image_free(m_LocalBuffer);
    }

    Texture::~Texture()
    {
        GLCall(glDeleteTextures(1, &m_RendererID));
    }

    void Texture::Bind(unsigned int slot) const
    {
        GLCall(glActiveTexture(GL_TEXTURE0 + slot));
        GLCall(glBindTexture(GL_TEXTURE_2D, m_RendererID));
    }

    void Texture::Unbind() const
    {
        GLCall(glBindTexture(GL_TEXTURE_2D, 0));
    }
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/FrameBuffer.h
====================
#pragma once

namespace Aether::Legacy {


    enum class FramebufferTextureFormat
	{
		None = 0,
		RGBA8,
		RED_INTEGER,
		DEPTH24STENCIL8,
		Depth = DEPTH24STENCIL8
	};

	struct FramebufferTextureSpecification
	{
		FramebufferTextureSpecification() = default;
		FramebufferTextureSpecification(FramebufferTextureFormat format)
			: TextureFormat(format) {}

		FramebufferTextureFormat TextureFormat = FramebufferTextureFormat::None;
	};

	struct FramebufferAttachmentSpecification
	{
		FramebufferAttachmentSpecification() = default;
		FramebufferAttachmentSpecification(std::initializer_list<FramebufferTextureSpecification> attachments)
			: Attachments(attachments) {}

		std::vector<FramebufferTextureSpecification> Attachments;
	};

	struct FramebufferSpecification
	{
		uint32_t Width = 0, Height = 0;
		FramebufferAttachmentSpecification Attachments;
		uint32_t Samples = 1;

		bool SwapChainTarget = false;
	};

	class AETHER_API FrameBuffer
	{
	public:
		FrameBuffer(const FramebufferSpecification& spec);
		 ~FrameBuffer();

		void Invalidate();

		void Bind() ;
		void Unbind() ;

		void Resize(uint32_t width, uint32_t height) ;
		int ReadPixel(uint32_t attachmentIndex, int x, int y) ;

		void ClearAttachment(uint32_t attachmentIndex, int value) ;

        void BindDepthTexture(uint32_t slot = 0) const;

		uint32_t GetColorAttachmentRendererID(uint32_t index = 0) const  { AE_CORE_ASSERT(index < m_ColorAttachments.size()); return m_ColorAttachments[index]; }
        uint32_t GetDepthAttachmentRendererID() const { return m_DepthAttachment; }

		const FramebufferSpecification& GetSpecification() const  { return m_Specification; }
	private:
		uint32_t m_RendererID = 0;
		FramebufferSpecification m_Specification;

		std::vector<FramebufferTextureSpecification> m_ColorAttachmentSpecifications;
		FramebufferTextureSpecification m_DepthAttachmentSpecification = FramebufferTextureFormat::None;

		std::vector<uint32_t> m_ColorAttachments;
		uint32_t m_DepthAttachment = 0;
	};

}

====================
FILE: ./Aether/src/Platform/LegacyOpenGL/Shader.cpp
====================
#include "Shader.h"
#include "Renderer.h"
#include "Aether/Core/Base.h"

#include <iostream>
#include <fstream>
#include <sstream>
namespace Aether::Legacy {
    Shader::Shader(const std::string& filepath)
        : m_FilePath(filepath), m_RendererID(0)
    {
        ShaderProgramSource source = ParseShader(filepath);
        m_RendererID = CreateShader(source.VertexSource, source.FragmentSource);
        AE_TRACE("{0}", m_RendererID);
    }

    Shader::~Shader()
    {
        GLCall(glDeleteProgram(m_RendererID));
    }

    void Shader::Bind() const
    {
        GLCall(glUseProgram(m_RendererID));
    }

    void Shader::Unbind() const
    {
        GLCall(glUseProgram(0));
    }

    void Shader::SetUniform4f(const std::string& name, float v0, float v1, float v2, float v3)
    {
        GLCall(glUniform4f(GetUniformLocation(name), v0, v1, v2, v3));
    }

    void Shader::SetUniform1f(const std::string& name, float value)
    {
        GLCall(glUniform1f(GetUniformLocation(name), value));
    }

    void Shader::SetUniform1i(const std::string& name, int value)
    {
        GLCall(glUniform1i(GetUniformLocation(name), value));
    }

    void Shader::SetUniformMat4f(const std::string& name, const glm::mat4& matrix)
    {
        GLCall(glUniformMatrix4fv(GetUniformLocation(name), 1, GL_FALSE, &matrix[0][0]));
    }

    void Shader::SetUniformMat4fv(const std::string& name, unsigned int count, const float* value)
    {
        glUniformMatrix4fv(GetUniformLocation(name), count, GL_FALSE, value);
    }

    void Shader::SetUniform3f(const std::string& name, const glm::vec3& value)
    {
        glUniform3f(GetUniformLocation(name), value.x, value.y, value.z);
    }

    int Shader::GetUniformLocation(const std::string& name)
    {
        if(m_UniformLocationCache.find(name) != m_UniformLocationCache.end())
            return m_UniformLocationCache[name];

        GLCall(int location = glGetUniformLocation(m_RendererID, name.c_str()));
        if (location == -1)
            std::cout << "Warning: uniform '" << name << "' doesn't exist!" << std::endl;
        m_UniformLocationCache[name] = location;
        return location;
    }

    ShaderProgramSource Shader::ParseShader(const std::string& filepath)
    {
        std::ifstream stream(filepath);

        enum class ShaderType
        {
            NONE = -1, VERTEX = 0, FRAGMENT = 1
        };

        std::string line;
        std::stringstream ss[2];
        ShaderType type = ShaderType::NONE;
        while (getline(stream, line))
        {
            if (line.find("#shader") != std::string::npos)
            {
                if (line.find("vertex") != std::string::npos) 
                    type = ShaderType::VERTEX;
                else if (line.find("fragment") != std::string::npos) 
                    type = ShaderType::FRAGMENT;
            }
            else
            {
                ss[(int)type] << line << '\n';
            }
        }

        return {ss[0].str(), ss[1].str()};
    }

    unsigned int Shader::CompileShader(unsigned int type, const std::string& source)
    {
        unsigned int id;
        GLCall(id = glCreateShader(type));
        const char* src = source.c_str();
        GLCall(glShaderSource(id, 1, &src, nullptr));
        GLCall(glCompileShader(id));

        int result;
        GLCall(glGetShaderiv(id, GL_COMPILE_STATUS, &result));
        if(result == GL_FALSE)
        {
            int lenght;
            GLCall(glGetShaderiv(id, GL_INFO_LOG_LENGTH, &lenght));
            char* message = (char*)alloca(lenght * sizeof(char));
            GLCall(glGetShaderInfoLog(id, lenght, &lenght, message));
            std::cout << "Failed to compile " << (type == GL_VERTEX_SHADER ? "vertex" : "fragment") << "shader" << std::endl;
            std::cout << message << std::endl;
            GLCall(glDeleteShader(id));
            return 0;
        }

        return id;
    }

    unsigned int Shader::CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
    {
        unsigned int program;
        GLCall(program = glCreateProgram());
        unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
        unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

        GLCall(glAttachShader(program, vs));
        GLCall(glAttachShader(program, fs));
        GLCall(glLinkProgram(program));
        GLCall(glValidateProgram(program));

        GLCall(glDeleteShader(vs));
        GLCall(glDeleteShader(fs));

        return program;
    }
}


====================
FILE: ./Aether/src/Platform/LegacyOpenGL/VertexBufferLayout.h
====================
#pragma once

#include <vector>
#include "Renderer.h"

namespace Aether::Legacy { 
    struct AETHER_API VertexBufferElement
    {
        unsigned int type;
        unsigned int count;
        unsigned char normalized;

        static unsigned int GetSizeOfType(unsigned int type)
        {
            switch (type)
            {
                case GL_FLOAT:         return sizeof(GLfloat);
                case GL_UNSIGNED_INT:  return sizeof(GLuint);
                case GL_UNSIGNED_BYTE: return sizeof(GLubyte);
            }
            ASSERT(false);
            return 0;
        }
    };

    class VertexBufferLayout
    {
    private:
        std::vector<VertexBufferElement> m_Elements;
        unsigned int m_Stride;
    public:
        VertexBufferLayout()
            : m_Stride(0) {}

        template<typename T>
        void Push(unsigned int count)
        {
            static_assert(false);
        }

        template<>
        void Push<float>(unsigned int count)
        {
            m_Elements.push_back({GL_FLOAT, count, GL_FALSE});
            m_Stride += count * VertexBufferElement::GetSizeOfType(GL_FLOAT);
        }

        template<>
        void Push<unsigned int>(unsigned int count)
        {
            m_Elements.push_back({GL_UNSIGNED_INT, count, GL_FALSE});
            m_Stride += count * VertexBufferElement::GetSizeOfType(GL_UNSIGNED_INT);
        }

        template<>
        void Push<unsigned char>(unsigned int count)
        {
            m_Elements.push_back({GL_UNSIGNED_BYTE, count, GL_TRUE});
            m_Stride += count * VertexBufferElement::GetSizeOfType(GL_UNSIGNED_BYTE);
        }

        inline const std::vector<VertexBufferElement> GetElements() const {return m_Elements;}
        inline unsigned int GetStride() const {return m_Stride;}
    };
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/VertexArray.h
====================
#pragma once

#include "VertexBuffer.h"

namespace Aether::Legacy {
    class VertexBufferLayout;

    class AETHER_API VertexArray
    {
    private:
        unsigned int m_RendererID;
    public:
        VertexArray();
        ~VertexArray();

        void AddBuffer(const VertexBuffer& vb, const VertexBufferLayout& layout);

        void Bind() const;
        void Unbind() const;
    };
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/Texture.h
====================
#pragma once

#include "Renderer.h"

namespace Aether::Legacy { 
    class AETHER_API Texture
    {
    private:
        unsigned int m_RendererID;
        std::string m_FilePath;
        unsigned char* m_LocalBuffer;
        int m_Width, m_Height, m_BPP;
    public:
        Texture(const std::string& path);
        ~Texture();

        void Bind(unsigned int slot = 0) const;
        void Unbind() const;

        inline int GetWidth() const {return m_Width;}
        inline int GetHeight() const {return m_Height;}
    };
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/VertexBuffer.h
====================
#pragma once

namespace Aether::Legacy { 
    class AETHER_API VertexBuffer
    {
    private:
        unsigned int m_RendererID;

    public:
        VertexBuffer(const void* data, unsigned int size);
        ~VertexBuffer();

        void Bind() const;
        void Unbind() const;
    };
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/IndexBuffer.cpp
====================
#include "IndexBuffer.h"
#include "Renderer.h"

namespace Aether::Legacy {
    IndexBuffer::IndexBuffer(const unsigned int* data, unsigned int count)
        : m_Count(count)
    {
        ASSERT(sizeof(unsigned int) == sizeof(GLuint));

        GLCall(glGenBuffers(1, &m_RendererID));
        GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_RendererID));
        GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, count * sizeof(unsigned int), data, GL_STATIC_DRAW));
    }

    IndexBuffer::~IndexBuffer()
    {
        GLCall(glDeleteBuffers(1, &m_RendererID));
    }

    void IndexBuffer::Bind() const
    {
        GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_RendererID));
    }

    void IndexBuffer::Unbind() const
    {
        GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0));
    }
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/Renderer.cpp
====================
#include "Renderer.h"
#include <iostream>

namespace Aether::Legacy {
    void GLClearError()
    {
        while (glGetError() != GL_NO_ERROR);
    }

    bool GLLogCall(const char* function, const char* file, int line)
    {
        while (GLenum error = glGetError())
        {
            std::cout << "[OpenGL Error] (" << error << "): " << function << " " << file << ":" << line << std::endl;
            return false;
        }
        return true;
    }

    void Renderer::Clear()
    {
        GLCall(glClear(GL_COLOR_BUFFER_BIT));
    }

    void Renderer::Draw(const VertexArray& va, const IndexBuffer& ib, const Shader& shader) const
    {
        shader.Bind();
        va.Bind();
        ib.Bind();
        GLCall(glDrawElements(GL_TRIANGLES, ib.GetCount(), GL_UNSIGNED_INT, nullptr));
    }
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/res/shaders/ShadowMap.shader
====================
#shader vertex
#version 330 core

layout(location = 0) in vec3 a_Pos;
// Các attribute khác (Normal, TexCoord) không cần thiết cho Shadow Map pass

uniform mat4 u_LightSpaceMatrix;
uniform mat4 u_Model;

void main()
{
    gl_Position = u_LightSpaceMatrix * u_Model * vec4(a_Pos, 1.0);
}

#shader fragment
#version 330 core

void main()
{
    // Không cần làm gì cả, Depth Buffer sẽ tự động được ghi
    // Có thể thêm: gl_FragDepth = gl_FragCoord.z; (nhưng không bắt buộc)
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/res/shaders/Basic.shader
====================
#shader vertex 
#version 330 core

layout(location = 0) in vec4 position; layout(location = 1) in vec2 texCoord;

out vec2 v_TexCoord;

uniform mat4 u_MVP;

void main() { gl_Position = u_MVP * position; v_TexCoord = texCoord; }

#shader fragment 
#version 330 core

layout(location = 0) out vec4 color;

in vec2 v_TexCoord;

uniform vec4 u_Color; uniform sampler2D u_Texture;

void main() 
{ 
    float r = texture(u_Texture, v_TexCoord + vec2(-aberrationAmount, 0.0)).r;
    float g = texture(u_Texture, v_TexCoord).g;
    float b = texture(u_Texture, v_TexCoord + vec2(aberrationAmount, 0.0)).b;
    vec4 texColor = vec4(r, g, b, texture(u_Texture, v_TexCoord).a);

    vec2 position = (v_TexCoord - 0.5) * 2.0;
    float len = length(position);
    float vignette = smoothstep(1.5, 0.5, len); 

    color = texColor * u_Color * vignette;
}
====================
FILE: ./Aether/src/Platform/LegacyOpenGL/res/shaders/LightingShadow.shader
====================
#shader vertex
#version 410 core

layout(location = 0) in vec3 a_Pos;
layout(location = 1) in vec3 a_Normal;
layout(location = 2) in vec2 a_TexCoord;

out vec3 v_FragPos;
out vec3 v_Normal;
out vec2 v_TexCoord;
out vec4 v_FragPosLightSpace;

uniform mat4 u_Model;
uniform mat4 u_View;
uniform mat4 u_Projection;
uniform mat4 u_LightSpaceMatrix;

void main()
{
    v_FragPos = vec3(u_Model * vec4(a_Pos, 1.0));
    v_Normal = mat3(transpose(inverse(u_Model))) * a_Normal; // Xử lý normal khi scale lệch
    v_TexCoord = a_TexCoord;
    
    // Chuyển vị trí vertex sang không gian ánh sáng để so sánh với Shadow Map
    v_FragPosLightSpace = u_LightSpaceMatrix * vec4(v_FragPos, 1.0);
    
    gl_Position = u_Projection * u_View * vec4(v_FragPos, 1.0);
}

#shader fragment
#version 410 core

out vec4 FragColor;

in vec3 v_FragPos;
in vec3 v_Normal;
in vec2 v_TexCoord;
in vec4 v_FragPosLightSpace;

uniform sampler2D u_Texture;    // Slot 0 (Texture gỗ)
uniform sampler2D u_ShadowMap;  // Slot 1 (Shadow Map - Depth Texture)

uniform vec3 u_LightPos;
uniform vec3 u_ViewPos;

// Hàm tính toán bóng đổ (0.0 = tối hoàn toàn, 1.0 = sáng hoàn toàn)
float ShadowCalculation(vec4 fragPosLightSpace, vec3 normal, vec3 lightDir)
{
    // 1. Chuyển từ clip space (-1, 1) sang range [0, 1] để sample texture
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;

    // Nếu nằm ngoài vùng nhìn thấy của đèn thì coi như không có bóng
    if(projCoords.z > 1.0)
        return 0.0;

    // 2. Lấy độ sâu gần nhất từ Shadow Map
    float closestDepth = texture(u_ShadowMap, projCoords.xy).r; 
    
    // 3. Lấy độ sâu hiện tại của pixel
    float currentDepth = projCoords.z;

    // 4. Tính Bias để tránh hiện tượng Shadow Acne (sọc đen trên bề mặt)
    // Bias thay đổi dựa trên góc chiếu sáng
    float bias = max(0.005 * (1.0 - dot(normal, lightDir)), 0.0005);  

    // 5. PCF (Percentage-closer filtering) - Làm mềm bóng
    // Lấy trung bình các mẫu xung quanh pixel hiện tại thay vì chỉ 1 điểm
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(u_ShadowMap, 0);
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(u_ShadowMap, projCoords.xy + vec2(x, y) * texelSize).r; 
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;        
        }    
    }
    shadow /= 9.0;

    return shadow;
}

void main()
{
    vec3 color = texture(u_Texture, v_TexCoord).rgb;
    vec3 normal = normalize(v_Normal);
    vec3 lightColor = vec3(1.0);

    // -- Ambient --
    vec3 ambient = 0.3 * color;

    // -- Diffuse --
    vec3 lightDir = normalize(u_LightPos - v_FragPos);
    float diff = max(dot(normal, lightDir), 0.0);
    vec3 diffuse = diff * lightColor;

    // -- Specular --
    vec3 viewDir = normalize(u_ViewPos - v_FragPos);
    vec3 reflectDir = reflect(-lightDir, normal);
    float spec = 0.0;
    vec3 halfwayDir = normalize(lightDir + viewDir);  
    spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0);
    vec3 specular = spec * lightColor;    

    // -- Tính Shadow --
    float shadow = ShadowCalculation(v_FragPosLightSpace, normal, lightDir);       
    
    // Tổng hợp ánh sáng (Shadow chỉ ảnh hưởng Diffuse và Specular, Ambient giữ nguyên)
    vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color;    
    
    FragColor = vec4(lighting, 1.0);
}
====================
FILE: ./Aether/src/Platform/OpenGL/OpenGLRendererAPI.h
====================
#pragma once

#include "Aether/Renderer/RendererAPI.h"

namespace Aether {

	class OpenGLRendererAPI : public RendererAPI
	{
	public:
		virtual void Init() override;
		virtual void SetViewport(uint32_t x, uint32_t y, uint32_t width, uint32_t height) override;

		virtual void SetClearColor(const glm::vec4& color) override;
		virtual void Clear() override;

		
	};
}

====================
FILE: ./Aether/src/Platform/OpenGL/OpenGLContext.cpp
====================
#include "aepch.h"
#include "Platform/OpenGL/OpenGLContext.h"

#include <GLFW/glfw3.h>
#include <glad/glad.h>

namespace Aether {

	OpenGLContext::OpenGLContext(GLFWwindow* windowHandle)
		: m_WindowHandle(windowHandle)
	{
		AE_CORE_ASSERT(windowHandle, "Window handle is null!")
	}

	void OpenGLContext::Init()
	{

		glfwMakeContextCurrent(m_WindowHandle);
		int status = gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);
		AE_CORE_ASSERT(status, "Failed to initialize Glad!");

		AE_CORE_INFO("OpenGL Info:");
		AE_CORE_INFO("  Vendor: {0}", (const char*)glGetString(GL_VENDOR));
		AE_CORE_INFO("  Renderer: {0}", (const char*)glGetString(GL_RENDERER));
		AE_CORE_INFO("  Version: {0}", (const char*)glGetString(GL_VERSION));

		AE_CORE_ASSERT((GLVersion.major == 4 && GLVersion.minor == 1), "Aether requires OpenGL version 4.1!");
	}

	void OpenGLContext::SwapBuffers()
	{

		glfwSwapBuffers(m_WindowHandle);
	}

}

====================
FILE: ./Aether/src/Platform/OpenGL/OpenGLContext.h
====================
#pragma once

#include "Aether/Renderer/GraphicsContext.h"

struct GLFWwindow;

namespace Aether {

	class OpenGLContext : public GraphicsContext
	{
	public:
		OpenGLContext(GLFWwindow* windowHandle);

		virtual void Init() override;
		virtual void SwapBuffers() override;
	private:
		GLFWwindow* m_WindowHandle;
	};

}
====================
FILE: ./Aether/src/Platform/OpenGL/OpenGLRendererAPI.cpp
====================
#include "aepch.h"
#include "OpenGLRendererAPI.h"
#include <glad/glad.h>

namespace Aether 
{

    void OpenGLRendererAPI::Init()
	{
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

		glEnable(GL_DEPTH_TEST);
		glEnable(GL_LINE_SMOOTH);
	}

	void OpenGLRendererAPI::SetViewport(uint32_t x, uint32_t y, uint32_t width, uint32_t height)
	{
		glViewport(x, y, width, height);
	}

    void OpenGLRendererAPI::SetClearColor(const glm::vec4& color) {
        glClearColor(color.r, color.g, color.b, color.a);
    }

    void OpenGLRendererAPI::Clear() {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
}
====================
FILE: ./Aether/src/Aether/Renderer/GraphicsContext.h
====================
#pragma once

namespace Aether {

	class GraphicsContext
	{
	public:
		virtual ~GraphicsContext() = default;

		virtual void Init() = 0;
		virtual void SwapBuffers() = 0;

		static Scope<GraphicsContext> Create(void* window);
	};

}
====================
FILE: ./Aether/src/Aether/Renderer/RendererAPI.h
====================
#pragma once
#include <glm/glm.hpp>

namespace Aether {

    class AETHER_API RendererAPI 
    {
    public:
        enum class API {
            None = 0, OpenGL = 1
        };

    public:
        virtual ~RendererAPI() = default;
		virtual void Init() = 0;
		virtual void SetViewport(uint32_t x, uint32_t y, uint32_t width, uint32_t height) = 0;
        virtual void SetClearColor(const glm::vec4& color) = 0;
        virtual void Clear() = 0;
        

        static API GetAPI() { return s_API; }
        static Scope<RendererAPI> Create();
    private:
        static API s_API;
    };
}
====================
FILE: ./Aether/src/Aether/Renderer/RenderCommand.cpp
====================
#include "aepch.h"
#include "Aether/Renderer/RenderCommand.h"

namespace Aether {

	Scope<RendererAPI> RenderCommand::s_RendererAPI = RendererAPI::Create();

}
====================
FILE: ./Aether/src/Aether/Renderer/Renderer.h
====================

====================
FILE: ./Aether/src/Aether/Renderer/GraphicsContext.cpp
====================
#include "aepch.h"
#include "Aether/Renderer/GraphicsContext.h"
#include "Platform/OpenGL/OpenGLContext.h"

namespace Aether {

	Scope<GraphicsContext> GraphicsContext::Create(void* window)
	{
		return CreateScope<OpenGLContext>(static_cast<GLFWwindow*>(window));

		AE_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}

}
====================
FILE: ./Aether/src/Aether/Renderer/RendererAPI.cpp
====================
#include "aepch.h"
#include "Aether/Renderer/RendererAPI.h"

#include "Platform/OpenGL/OpenGLRendererAPI.h"

namespace Aether {

	RendererAPI::API RendererAPI::s_API = RendererAPI::API::OpenGL;

	Scope<RendererAPI> RendererAPI::Create()
	{
		switch (s_API)
		{
			case RendererAPI::API::None:    AE_CORE_ASSERT(false, "RendererAPI::None is currently not supported!"); return nullptr;
			case RendererAPI::API::OpenGL:  return CreateScope<OpenGLRendererAPI>();
		}

		AE_CORE_ASSERT(false, "Unknown RendererAPI!");
		return nullptr;
	}
}
====================
FILE: ./Aether/src/Aether/Renderer/RenderCommand.h
====================
#pragma once
#include "RendererAPI.h"

namespace Aether {
    class RenderCommand {
    public:
        static void Init() {
            s_RendererAPI->Init();
        }
        
        static void SetClearColor(const glm::vec4& color) {
            s_RendererAPI->SetClearColor(color);
        }

        static void Clear() {
            s_RendererAPI->Clear();
        }

    private:
        static Scope<RendererAPI> s_RendererAPI;
    };
}
====================
FILE: ./Aether/src/Aether/Renderer/Renderer.cpp
====================

====================
FILE: ./Aether/src/Aether/Renderer/Legacy/LegacyAPI.cpp
====================
#include "LegacyAPI.h"
#include <glad/glad.h> 

namespace Aether::Legacy {

    void LegacyAPI::Init() {
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glEnable(GL_DEPTH_TEST);
    }

    void LegacyAPI::SetViewport(int x, int y, int width, int height) {
        glViewport(x, y, width, height);
    }

    void LegacyAPI::SetClearColor(const glm::vec4& color) {
        glClearColor(color.r, color.g, color.b, color.a);
    }

    void LegacyAPI::Clear() {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    void LegacyAPI::Draw(const VertexArray& va, const IndexBuffer& ib, const Shader& shader) {
        shader.Bind();
        va.Bind();
        ib.Bind();
        glDrawElements(GL_TRIANGLES, ib.GetCount(), GL_UNSIGNED_INT, nullptr);
    }
}
====================
FILE: ./Aether/src/Aether/Renderer/Legacy/Camera.h
====================
#pragma once

#include <glad/glad.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include <vector>

namespace Aether::Legacy {
    // Hướng di chuyển
    enum Camera_Movement {
        FORWARD,
        BACKWARD,
        LEFT,
        RIGHT,
        UP,    // Bay lên (Space)
        DOWN   // Bay xuống (Shift/Ctrl)
    };

    // Các thông số mặc định
    const float YAW         = -90.0f; // Quay trái phải (mặc định nhìn về trục Z âm)
    const float PITCH       =  0.0f;  // Nhìn lên xuống
    const float SPEED       =  2.5f;  // Tốc độ di chuyển
    const float SENSITIVITY =  0.1f;  // Độ nhạy chuột
    const float ZOOM        =  45.0f; // Góc nhìn (FOV)

    class AETHER_API Camera
    {
    public:
        // Attributes
        glm::vec3 Position;
        glm::vec3 Front;
        glm::vec3 Up;
        glm::vec3 Right;
        glm::vec3 WorldUp;

        // Euler Angles
        float Yaw;
        float Pitch;

        // Options
        float MovementSpeed;
        float MouseSensitivity;
        float Zoom;

        // Constructor
        Camera(glm::vec3 position = glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f), float yaw = YAW, float pitch = PITCH) 
            : Front(glm::vec3(0.0f, 0.0f, -1.0f)), MovementSpeed(SPEED), MouseSensitivity(SENSITIVITY), Zoom(ZOOM)
        {
            Position = position;
            WorldUp = up;
            Yaw = yaw;
            Pitch = pitch;
            updateCameraVectors();
        }

        // Trả về Ma trận View (LookAt) - Đây là phép màu biến toạ độ thế giới thành toạ độ camera
        glm::mat4 GetViewMatrix()
        {
            return glm::lookAt(Position, Position + Front, Up);
        }

        // Xử lý bàn phím
        void ProcessKeyboard(Camera_Movement direction, float deltaTime)
        {
            float velocity = MovementSpeed * deltaTime;
            if (direction == FORWARD)
                Position += Front * velocity;
            if (direction == BACKWARD)
                Position -= Front * velocity;
            if (direction == LEFT)
                Position -= Right * velocity;
            if (direction == RIGHT)
                Position += Right * velocity;
            if (direction == UP)
                Position += WorldUp * velocity; // Bay lên thẳng đứng
            if (direction == DOWN)
                Position -= WorldUp * velocity; // Bay xuống
        }

        // Xử lý chuột
        void ProcessMouseMovement(float xoffset, float yoffset, bool constrainPitch = true)
        {
            xoffset *= MouseSensitivity;
            yoffset *= MouseSensitivity;

            Yaw   += xoffset;
            Pitch += yoffset;

            // Giới hạn nhìn lên/xuống để không bị lộn cổ (Gimbal lock)
            if (constrainPitch)
            {
                if (Pitch > 89.0f)
                    Pitch = 89.0f;
                if (Pitch < -89.0f)
                    Pitch = -89.0f;
            }

            updateCameraVectors();
        }

    private:
        // Tính toán lại các vector Front, Right, Up dựa trên góc quay mới
        void updateCameraVectors()
        {
            // Tính vector Front mới
            glm::vec3 front;
            front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
            front.y = sin(glm::radians(Pitch));
            front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
            Front = glm::normalize(front);
            
            // Tính lại Right và Up
            Right = glm::normalize(glm::cross(Front, WorldUp));  
            Up    = glm::normalize(glm::cross(Right, Front));
        }
    };
}
====================
FILE: ./Aether/src/Aether/Renderer/Legacy/LegacyAPI.h
====================
#pragma once

#include "glm/glm.hpp"

#include "Platform/LegacyOpenGL/VertexArray.h"
#include "Platform/LegacyOpenGL/VertexBuffer.h"
#include "Platform/LegacyOpenGL/IndexBuffer.h"
#include "Platform/LegacyOpenGL/Shader.h"
#include "Platform/LegacyOpenGL/Texture.h"
#include "Platform/LegacyOpenGL/VertexBufferLayout.h"
#include "Platform/LegacyOpenGL/FrameBuffer.h"
#include "Aether/Renderer/Legacy/Camera.h"

namespace Aether::Legacy {

    class AETHER_API LegacyAPI {
    public:
        static void Init();
        static void SetViewport(int x, int y, int width, int height);
        
        static void SetClearColor(const glm::vec4& color);
        static void Clear();

        static void Draw(const VertexArray& va, const IndexBuffer& ib, const Shader& shader);
    };

}
====================
FILE: ./Aether/src/Aether/Core/Input.h
====================
#pragma once

#include "Aether/Core/KeyCodes.h"
#include "Aether/Core/MouseCodes.h"

#include <glm/glm.hpp>

namespace Aether {

	enum class CursorMode {
        Normal = 0,
        Hidden = 1,
        Locked = 2 
    };

	class AETHER_API Input
	{
	public:
		static bool IsKeyPressed(KeyCode key);

		static bool IsMouseButtonPressed(MouseCode button);
		static glm::vec2 GetMousePosition();
		static float GetMouseX();
		static float GetMouseY();

		static void SetCursorMode(CursorMode mode);
	};
}

====================
FILE: ./Aether/src/Aether/Core/Log.cpp
====================
#include "aepch.h"
#include "Aether/Core/Log.h"

namespace Aether {

	Ref<spdlog::logger> Log::s_CoreLogger;
	Ref<spdlog::logger> Log::s_ClientLogger;

	void Log::Init()
	{
		std::vector<spdlog::sink_ptr> logSinks;

		logSinks.emplace_back(CreateRef<spdlog::sinks::basic_file_sink_mt>("Aether.log", true)); 
		logSinks[0]->set_pattern("[%T] [%l] %n: %v");

		//logSinks.emplace_back(CreateRef<spdlog::sinks::stdout_color_sink_mt>()); //console printer
		//logSinks[1]->set_pattern("%^[%T] %n: %v%$");//console printer

		s_CoreLogger = CreateRef<spdlog::logger>("AETHER", begin(logSinks), end(logSinks));
		spdlog::register_logger(s_CoreLogger);
		s_CoreLogger->set_level(spdlog::level::trace);
		s_CoreLogger->flush_on(spdlog::level::trace);

		s_ClientLogger = CreateRef<spdlog::logger>("APP", begin(logSinks), end(logSinks));
		spdlog::register_logger(s_ClientLogger);
		s_ClientLogger->set_level(spdlog::level::trace);
		s_ClientLogger->flush_on(spdlog::level::trace);
	}

}
====================
FILE: ./Aether/src/Aether/Core/Window.cpp
====================
#include "aepch.h"
#include "Aether/Core/Window.h"

#include "Platform/GLFW/GLFW_Window.h"

namespace Aether {
    Scope<Window> Window::Create(const WinProps& props)
	{
	    return CreateScope<GLFW_Window>(props);
	}
}
====================
FILE: ./Aether/src/Aether/Core/Application.h
====================
#pragma once

#include "Aether/Core/Window.h"
#include "Aether/Core/LayerStack.h"
#include "Aether/Events/Event.h"
#include "Aether/Events/ApplicationEvent.h"
#include "Aether/ImGui/ImGuiLayer.h"

#include "Aether/Core/Timestep.h"

namespace Aether {

    class AETHER_API Application
    {
    public:
        Application();
        virtual ~Application();

        void Run();
        void Close();
        void OnEvent(Event& e);

        void PushLayer(Layer* Layer);
        void PushOverlay(Layer* layer);

        static Application& Get() { return *s_Instance; }
        Window& GetWindow() { return *m_Window; }
    private:
        bool OnWindowClose(WindowCloseEvent& e);
        static Application* s_Instance;
        Scope<Window> m_Window;
        bool m_Running = true;
        LayerStack m_LayerStack;
        float m_LastFrameTime = 0.0f;
        ImGuiLayer* m_ImGuiLayer;
    };

    Application* CreateApplication();
}
====================
FILE: ./Aether/src/Aether/Core/Layer.h
====================
#pragma once

#include "Aether/Core/Base.h"
#include "Aether/Core/Timestep.h"
#include "Aether/Events/Event.h"

namespace Aether {

	class AETHER_API Layer
	{
	public:
		Layer(const std::string& name = "Layer");
		virtual ~Layer() = default;

		virtual void Attach() {}
		virtual void Detach() {}
		virtual void Update(Timestep ts) {}
		virtual void OnImGuiRender() {}
		virtual void OnEvent(Event& event) {}

		const std::string& GetName() const { return m_DebugName; }
	protected:
		std::string m_DebugName;
	};

}
====================
FILE: ./Aether/src/Aether/Core/Layer.cpp
====================
#include "aepch.h"
#include "Aether/Core/Layer.h"

namespace Aether {

	Layer::Layer(const std::string& debugName)
		: m_DebugName(debugName)
	{
	}
	
}
====================
FILE: ./Aether/src/Aether/Core/KeyCodes.h
====================
#pragma once

namespace Aether
{
	using KeyCode = uint16_t;
	
	namespace Key
	{
		enum : KeyCode
		{
			// From glfw3.h
			Space               = 32,
			Apostrophe          = 39, /* ' */
			Comma               = 44, /* , */
			Minus               = 45, /* - */
			Period              = 46, /* . */
			Slash               = 47, /* / */

			D0                  = 48, /* 0 */
			D1                  = 49, /* 1 */
			D2                  = 50, /* 2 */
			D3                  = 51, /* 3 */
			D4                  = 52, /* 4 */
			D5                  = 53, /* 5 */
			D6                  = 54, /* 6 */
			D7                  = 55, /* 7 */
			D8                  = 56, /* 8 */
			D9                  = 57, /* 9 */

			Semicolon           = 59, /* ; */
			Equal               = 61, /* = */

			A                   = 65,
			B                   = 66,
			C                   = 67,
			D                   = 68,
			E                   = 69,
			F                   = 70,
			G                   = 71,
			H                   = 72,
			I                   = 73,
			J                   = 74,
			K                   = 75,
			L                   = 76,
			M                   = 77,
			N                   = 78,
			O                   = 79,
			P                   = 80,
			Q                   = 81,
			R                   = 82,
			S                   = 83,
			T                   = 84,
			U                   = 85,
			V                   = 86,
			W                   = 87,
			X                   = 88,
			Y                   = 89,
			Z                   = 90,

			LeftBracket         = 91,  /* [ */
			Backslash           = 92,  /* \ */
			RightBracket        = 93,  /* ] */
			GraveAccent         = 96,  /* ` */

			World1              = 161, /* non-US #1 */
			World2              = 162, /* non-US #2 */

			/* Function keys */
			Escape              = 256,
			Enter               = 257,
			Tab                 = 258,
			Backspace           = 259,
			Insert              = 260,
			Delete              = 261,
			Right               = 262,
			Left                = 263,
			Down                = 264,
			Up                  = 265,
			PageUp              = 266,
			PageDown            = 267,
			Home                = 268,
			End                 = 269,
			CapsLock            = 280,
			ScrollLock          = 281,
			NumLock             = 282,
			PrintScreen         = 283,
			Pause               = 284,
			F1                  = 290,
			F2                  = 291,
			F3                  = 292,
			F4                  = 293,
			F5                  = 294,
			F6                  = 295,
			F7                  = 296,
			F8                  = 297,
			F9                  = 298,
			F10                 = 299,
			F11                 = 300,
			F12                 = 301,
			F13                 = 302,
			F14                 = 303,
			F15                 = 304,
			F16                 = 305,
			F17                 = 306,
			F18                 = 307,
			F19                 = 308,
			F20                 = 309,
			F21                 = 310,
			F22                 = 311,
			F23                 = 312,
			F24                 = 313,
			F25                 = 314,

			/* Keypad */
			KP0                 = 320,
			KP1                 = 321,
			KP2                 = 322,
			KP3                 = 323,
			KP4                 = 324,
			KP5                 = 325,
			KP6                 = 326,
			KP7                 = 327,
			KP8                 = 328,
			KP9                 = 329,
			KPDecimal           = 330,
			KPDivide            = 331,
			KPMultiply          = 332,
			KPSubtract          = 333,
			KPAdd               = 334,
			KPEnter             = 335,
			KPEqual             = 336,

			LeftShift           = 340,
			LeftControl         = 341,
			LeftAlt             = 342,
			LeftSuper           = 343,
			RightShift          = 344,
			RightControl        = 345,
			RightAlt            = 346,
			RightSuper          = 347,
			Menu                = 348
		};
	}
}
====================
FILE: ./Aether/src/Aether/Core/Window.h
====================
#pragma once

#include "Aether/Core/Base.h"
#include "Aether/Events/Event.h"

#include <sstream>

namespace Aether {

    struct WinProps
    {
        std::string Title;
        unsigned int Width;
        unsigned int Height;

        WinProps(const std::string& title = "Aether Engine", unsigned int width = 1600, unsigned int height = 900)
            :Title(title), Width(width), Height(height)
        {}
    };

    class AETHER_API Window
    {
    public:
        using EventCallbackFn = std::function<void(Event&)>;

        virtual ~Window() = default;

        virtual void Update() = 0;

        virtual unsigned int GetWidth() const = 0;
        virtual unsigned int GetHeight() const = 0;

        virtual void SetEventCallback(const EventCallbackFn& callback) = 0;
        virtual void SetVSync(bool enabled) = 0;
        virtual bool IsVSync() const = 0;

        virtual void* GetWindow() const = 0;

        static Scope<Window> Create(const WinProps& props = WinProps());
    };
}
====================
FILE: ./Aether/src/Aether/Core/Timestep.h
====================
#pragma once

namespace Aether {

	class AETHER_API Timestep
	{
	public:
		Timestep(float time = 0.0f)
			: m_Time(time)
		{
		}

		operator float() const { return m_Time; }

		float GetSeconds() const { return m_Time; }
		float GetMilliseconds() const { return m_Time * 1000.0f; }
	private:
		float m_Time;
	};

}
====================
FILE: ./Aether/src/Aether/Core/EntryPoint.h
====================
#pragma once
#include "Application.h"

extern Aether::Application* Aether::CreateApplication();

int main(int argc, char** argv)
{
    Aether::Log::Init();
    AE_CORE_WARN("Initialized Log!");
    auto app = Aether::CreateApplication();
    app->Run();
    delete app;
}

====================
FILE: ./Aether/src/Aether/Core/Timer.h
====================
#pragma once

#include <chrono>

namespace Aether {

	class Timer
	{
	public:
		Timer()
		{
			Reset();
		}

		void Timer::Reset()
		{
			m_Start = std::chrono::high_resolution_clock::now();
		}

		float Timer::Elapsed()
		{
			return std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now() - m_Start).count() * 0.001f * 0.001f * 0.001f;
		}

		float Timer::ElapsedMillis()
		{
			return Elapsed() * 1000.0f;
		}

	private:
		std::chrono::time_point<std::chrono::high_resolution_clock> m_Start;
	};

}

====================
FILE: ./Aether/src/Aether/Core/LayerStack.cpp
====================
#include "aepch.h"
#include "Aether/Core/LayerStack.h"

namespace Aether {

	LayerStack::~LayerStack()
	{
		for (Layer* layer : m_Layers)
		{
			layer->Detach();
			delete layer;
		}
	}

	void LayerStack::PushLayer(Layer* layer)
	{
		m_Layers.emplace(m_Layers.begin() + m_LayerInsertIndex, layer);
		m_LayerInsertIndex++;
	}

	void LayerStack::PushOverlay(Layer* overlay)
	{
		m_Layers.emplace_back(overlay);
	}

	void LayerStack::PopLayer(Layer* layer)
	{
		auto it = std::find(m_Layers.begin(), m_Layers.begin() + m_LayerInsertIndex, layer);
		if (it != m_Layers.begin() + m_LayerInsertIndex)
		{
			layer->Detach();
			m_Layers.erase(it);
			m_LayerInsertIndex--;
		}
	}

	void LayerStack::PopOverlay(Layer* overlay)
	{
		auto it = std::find(m_Layers.begin() + m_LayerInsertIndex, m_Layers.end(), overlay);
		if (it != m_Layers.end())
		{
			overlay->Detach();
			m_Layers.erase(it);
		}
	}

}

====================
FILE: ./Aether/src/Aether/Core/Log.h
====================
#pragma once

#include "Base.h"
#include "spdlog/spdlog.h"
#include "spdlog/fmt/ostr.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/sinks/basic_file_sink.h"


namespace Aether {

	class AETHER_API Log
	{
	public:
		static void Init();

		static Ref<spdlog::logger>& GetCoreLogger() { return s_CoreLogger; }
		static Ref<spdlog::logger>& GetClientLogger() { return s_ClientLogger; }
	private:
		static Ref<spdlog::logger> s_CoreLogger;
		static Ref<spdlog::logger> s_ClientLogger;
	};
	template<typename T, typename = void>
	struct has_to_string : std::false_type {};

	template<typename T>
	struct has_to_string<T, std::void_t<decltype(std::declval<T>().ToString())>> : std::true_type {};

	template<typename T>
	decltype(auto) ConvertLogArg(const T& arg)
	{
		if constexpr (has_to_string<T>::value) {
			return arg.ToString();
		}
		else {
			return arg;
		}
	}

	template<typename... Args>
	void LogWrapper(std::shared_ptr<spdlog::logger>& logger, spdlog::level::level_enum level, Args&&... args)
	{
		logger->log(level, ConvertLogArg(std::forward<Args>(args))...);
	}
}

#define AE_CORE_TRACE(...)   ::Aether::LogWrapper(::Aether::Log::GetCoreLogger(), spdlog::level::trace, __VA_ARGS__)
#define AE_CORE_INFO(...)    ::Aether::LogWrapper(::Aether::Log::GetCoreLogger(), spdlog::level::info, __VA_ARGS__)
#define AE_CORE_WARN(...)    ::Aether::LogWrapper(::Aether::Log::GetCoreLogger(), spdlog::level::warn, __VA_ARGS__)
#define AE_CORE_ERROR(...)   ::Aether::LogWrapper(::Aether::Log::GetCoreLogger(), spdlog::level::err, __VA_ARGS__)
#define AE_CORE_FATAL(...)   ::Aether::LogWrapper(::Aether::Log::GetCoreLogger(), spdlog::level::critical, __VA_ARGS__)

// Client log macros
#define AE_TRACE(...)        ::Aether::LogWrapper(::Aether::Log::GetClientLogger(), spdlog::level::trace, __VA_ARGS__)
#define AE_INFO(...)         ::Aether::LogWrapper(::Aether::Log::GetClientLogger(), spdlog::level::info, __VA_ARGS__)
#define AE_WARN(...)         ::Aether::LogWrapper(::Aether::Log::GetClientLogger(), spdlog::level::warn, __VA_ARGS__)
#define AE_ERROR(...)        ::Aether::LogWrapper(::Aether::Log::GetClientLogger(), spdlog::level::err, __VA_ARGS__)
#define AE_FATAL(...)        ::Aether::LogWrapper(::Aether::Log::GetClientLogger(), spdlog::level::critical, __VA_ARGS__)
====================
FILE: ./Aether/src/Aether/Core/MouseCodes.h
====================
#pragma once

namespace Aether
{
	using MouseCode = uint16_t;

	namespace Mouse
	{
		enum : MouseCode
		{
			// From glfw3.h
			Button0                = 0,
			Button1                = 1,
			Button2                = 2,
			Button3                = 3,
			Button4                = 4,
			Button5                = 5,
			Button6                = 6,
			Button7                = 7,

			ButtonLast             = Button7,
			ButtonLeft             = Button0,
			ButtonRight            = Button1,
			ButtonMiddle           = Button2
		};
	}
}
====================
FILE: ./Aether/src/Aether/Core/Application.cpp
====================
#include "aepch.h"
#include "Application.h"
#include "Aether/Core/Log.h"

#include "Aether/Core/Input.h"
#include "Aether/Utils/PlatformUtils.h"

namespace Aether {
    Application* Application::s_Instance = nullptr;

    Application::Application()
    {
        s_Instance = this;
        m_Window = Window::Create(WinProps("Aether Engine", 800, 600));
        m_Window->SetEventCallback(AE_BIND_EVENT_FN(OnEvent));

        m_ImGuiLayer = new ImGuiLayer();
        PushOverlay(m_ImGuiLayer);
    }

    Application::~Application()
    {
    }

    void Application::Close()
	{
		m_Running = false;
	}

    void Application::PushLayer(Layer* layer)
    {
        m_LayerStack.PushLayer(layer);
        layer->Attach();
    }

    void Application::PushOverlay(Layer* layer)
    {
        m_LayerStack.PushOverlay(layer);
        layer->Attach();
    }

    void Application::OnEvent(Event& e)
    {
        EventDispatcher dispatcher(e);
        dispatcher.Dispatch<WindowCloseEvent>(AE_BIND_EVENT_FN(OnWindowClose));

        AE_CORE_TRACE("{0}", e);

        for (auto it = m_LayerStack.end(); it != m_LayerStack.begin();)
        {
            (*--it)->OnEvent(e);
            if (e.Handled)
                break;
        }
    }

    void Application::Run()
    {
        while (m_Running)
        {
            float time = Time::GetTime();
			Timestep timestep = time - m_LastFrameTime;
			m_LastFrameTime = time;

            for (Layer* layer : m_LayerStack) layer->Update(timestep);
            

            m_ImGuiLayer->Begin(); 
            {
                for (Layer* layer : m_LayerStack)
                    layer->OnImGuiRender();
            }
            m_ImGuiLayer->End();

            m_Window->Update();
        }
    }

    bool Application::OnWindowClose(WindowCloseEvent& e)
    {
        m_Running = false; 
        return true;
    }

}
====================
FILE: ./Aether/src/Aether/Core/LayerStack.h
====================
#pragma once

#include "Aether/Core/Base.h"
#include "Aether/Core/Layer.h"

#include <vector>

namespace Aether {

	class AETHER_API LayerStack
	{
	public:
		LayerStack() = default;
		~LayerStack();

		void PushLayer(Layer* layer);
		void PushOverlay(Layer* overlay);
		void PopLayer(Layer* layer);
		void PopOverlay(Layer* overlay);

		std::vector<Layer*>::iterator begin() { return m_Layers.begin(); }
		std::vector<Layer*>::iterator end() { return m_Layers.end(); }
		std::vector<Layer*>::reverse_iterator rbegin() { return m_Layers.rbegin(); }
		std::vector<Layer*>::reverse_iterator rend() { return m_Layers.rend(); }

		std::vector<Layer*>::const_iterator begin() const { return m_Layers.begin(); }
		std::vector<Layer*>::const_iterator end()	const { return m_Layers.end(); }
		std::vector<Layer*>::const_reverse_iterator rbegin() const { return m_Layers.rbegin(); }
		std::vector<Layer*>::const_reverse_iterator rend() const { return m_Layers.rend(); }
	private:
		std::vector<Layer*> m_Layers;
		unsigned int m_LayerInsertIndex = 0;
	};

}
====================
FILE: ./Aether/src/Aether/Core/Assert.h
====================
#pragma once

#include "Aether/Core/Base.h"
#include "Aether/Core/Log.h"
#include <filesystem>

#ifdef AE_ENABLE_ASSERTS

	#define AE_INTERNAL_ASSERT_IMPL(type, check, msg, ...) { if(!(check)) { AE##type##ERROR(msg, __VA_ARGS__); AE_DEBUGBREAK(); } }
	#define AE_INTERNAL_ASSERT_WITH_MSG(type, check, ...) AE_INTERNAL_ASSERT_IMPL(type, check, "Assertion failed: {0}", __VA_ARGS__)
	#define AE_INTERNAL_ASSERT_NO_MSG(type, check) AE_INTERNAL_ASSERT_IMPL(type, check, "Assertion '{0}' failed at {1}:{2}", AE_STRINGIFY_MACRO(check), std::filesystem::path(__FILE__).filename().string(), __LINE__)

	#define AE_INTERNAL_ASSERT_GET_MACRO_NAME(arg1, arg2, macro, ...) macro
	#define AE_INTERNAL_ASSERT_GET_MACRO(...) AE_EXPAND_MACRO( AE_INTERNAL_ASSERT_GET_MACRO_NAME(__VA_ARGS__, AE_INTERNAL_ASSERT_WITH_MSG, AE_INTERNAL_ASSERT_NO_MSG) )

	#define AE_ASSERT(...) AE_EXPAND_MACRO( AE_INTERNAL_ASSERT_GET_MACRO(__VA_ARGS__)(_, __VA_ARGS__) )
	#define AE_CORE_ASSERT(...) AE_EXPAND_MACRO( AE_INTERNAL_ASSERT_GET_MACRO(__VA_ARGS__)(_CORE_, __VA_ARGS__) )

#else
	#define AE_ASSERT(...)
	#define AE_CORE_ASSERT(...)
#endif
====================
FILE: ./Aether/src/Aether/Core/Base.h
====================
#pragma once

#include <memory>

#ifdef _WIN32
	#ifdef _WIN64
		#define AETHER_PLATFORM_WINDOWS
	#else
		#error "x86 Builds are not supported!"
	#endif
#elif defined(__APPLE__) || defined(__MACH__)
	#include <TargetConditionals.h>
	#if TARGET_OS_MAC == 1
		#define AETHER_PLATFORM_MACOS
	#else
		#error "MacOS only!"
	#endif
#elif defined(__linux__)
	#define AETHER_PLATFORM_LINUX
#else
	#error "Unknown platform!"
#endif

#ifdef AETHER_PLATFORM_WINDOWS
	#ifdef AETHER_BUILD_DLL
		#define AETHER_API __declspec(dllexport)
	#else
		#define AETHER_API __declspec(dllimport)
	#endif
#else
	#define AETHER_API __attribute__((visibility("default")))
#endif

#ifdef AETHER_PLATFORM_WINDOWS
	#define AE_DEBUGBREAK() __debugbreak()
#elif defined(AETHER_PLATFORM_LINUX) || defined(AETHER_PLATFORM_MACOS)
	#include <signal.h>
	#define AE_DEBUGBREAK() raise(SIGTRAP)
#else
	#define AE_DEBUGBREAK()
#endif

#ifdef AETHER_DEBUG
	#define AE_ENABLE_ASSERTS
#endif

#define AE_EXPAND_MACRO(x) x
#define AE_STRINGIFY_MACRO(x) #x
#define BIT(x) (1 << x)
#define AE_BIND_EVENT_FN(fn) [this](auto&&... args) -> decltype(auto) { return this->fn(std::forward<decltype(args)>(args)...); }

namespace Aether {

	template<typename T>
	using Scope = std::unique_ptr<T>;
	template<typename T, typename ... Args>
	constexpr Scope<T> CreateScope(Args&& ... args)
	{
		return std::make_unique<T>(std::forward<Args>(args)...);
	}

	template<typename T>
	using Ref = std::shared_ptr<T>;
	template<typename T, typename ... Args>
	constexpr Ref<T> CreateRef(Args&& ... args)
	{
		return std::make_shared<T>(std::forward<Args>(args)...);
	}

}

#include "Aether/Core/Log.h"
#include "Aether/Core/Assert.h"
====================
FILE: ./Aether/src/Aether/ImGui/ImGuiLayer.h
====================
#pragma once

#include "Aether/Core/Layer.h"
#include "Aether/Core/Log.h"

#include "imgui.h"
#include "backends/imgui_impl_glfw.h"
#include "backends/imgui_impl_opengl3.h"

namespace Aether {

    class AETHER_API ImGuiLayer : public Layer
    {
    public:
        ImGuiLayer();
        ~ImGuiLayer();

        static ImGuiContext* GetContext();

        virtual void Attach() override;
        virtual void Detach() override;
        virtual void OnImGuiRender() override;

        void Begin();
        void End();

    private:
        float m_Time = 0.0f;
    };
}
====================
FILE: ./Aether/src/Aether/ImGui/ImGuiLayer.cpp
====================
#include "ImGuiLayer.h"

#include "Aether/Core/Application.h"

#include <GLFW/glfw3.h>
#include <glad/glad.h>

namespace Aether {

    ImGuiLayer::ImGuiLayer()
        : Layer("ImGuiLayer")
    {
    }

    ImGuiLayer::~ImGuiLayer()
    {
    }

    ImGuiContext* ImGuiLayer::GetContext() 
    {
        return ImGui::GetCurrentContext();
    }

    void ImGuiLayer::Attach()
    {
        // Setup Dear ImGui context
        IMGUI_CHECKVERSION();
        ImGui::CreateContext();
        ImGuiIO& io = ImGui::GetIO(); (void)io;
        
        io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;
        io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;
        io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable;

        // Setup Dear ImGui style
        ImGui::StyleColorsDark();

        // When viewports are enabled we tweak WindowRounding/WindowBg
        ImGuiStyle& style = ImGui::GetStyle();
        if (io.ConfigFlags & ImGuiConfigFlags_ViewportsEnable)
        {
            style.WindowRounding = 0.0f;
            style.Colors[ImGuiCol_WindowBg].w = 1.0f;
        }

        // Setup Platform/Renderer backends
        Application& app = Application::Get();
        GLFWwindow* window = static_cast<GLFWwindow*>(app.GetWindow().GetWindow());

        ImGui_ImplGlfw_InitForOpenGL(window, true);
        
        ImGui_ImplOpenGL3_Init(nullptr);
    
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();
        ImGui::Render();
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        
        AE_CORE_INFO("ImGui font atlas uploaded to GPU");
    }

    void ImGuiLayer::Detach()
    {
        ImGui_ImplOpenGL3_Shutdown();
        ImGui_ImplGlfw_Shutdown();
        ImGui::DestroyContext();
    }
    
    // Hàm này để test thử xem ImGui có hiện không
    void ImGuiLayer::OnImGuiRender()
    {
        static bool show = true;
        //ImGui::ShowDemoWindow(&show); // Bật dòng này lên nếu muốn xem Demo của ImGui
    }

    void ImGuiLayer::Begin()
    {
        AE_CORE_TRACE("ImGui Begin - Step 1");
        ImGui_ImplGlfw_NewFrame();
        AE_CORE_INFO("ImGui Begin - Step 2");
        ImGui_ImplOpenGL3_NewFrame();
        AE_CORE_INFO("ImGui Begin - Step 3");
        ImGui::NewFrame();
        AE_CORE_INFO("ImGui Begin - Complete");
    }

    void ImGuiLayer::End()
    {
        AE_CORE_INFO("ImGui End - Step 1: Get IO");
        ImGuiIO& io = ImGui::GetIO();
        Application& app = Application::Get();
        io.DisplaySize = ImVec2((float)app.GetWindow().GetWidth(), (float)app.GetWindow().GetHeight());

        AE_CORE_INFO("ImGui End - Step 2: Render");
        ImGui::Render();
        
        AE_CORE_INFO("ImGui End - Step 3: RenderDrawData");
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        AE_CORE_INFO("ImGui End - Step 4: Viewports");
        {
            GLFWwindow* backup_current_context = glfwGetCurrentContext();
            ImGui::UpdatePlatformWindows();
            ImGui::RenderPlatformWindowsDefault();
            glfwMakeContextCurrent(backup_current_context);
        }
        AE_CORE_INFO("ImGui End - Complete");
    }
}
====================
FILE: ./Aether/src/Aether/Utils/PlatformUtils.h
====================
#pragma once

#include <string>

namespace Aether {
 
	class AETHER_API FileDialogs
	{
	public:
		// These return empty strings if cancelled
		static std::string OpenFile(const char* filter);
		static std::string SaveFile(const char* filter);
	};

	class AETHER_API Time
	{
	public:
		static float GetTime();
	};

}

====================
FILE: ./Aether/src/Aether/Events/Event.h
====================
#pragma once

#include "Aether/Core/Base.h"

#include <functional>
#include <string>
#include <ostream> 
#include <spdlog/fmt/ostr.h>



namespace Aether 
{
	enum class EventType
	{
		None = 0,
		WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved,
		AppTick, AppUpdate, AppRender,
		KeyPressed, KeyReleased, KeyTyped,
		MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled
	};

	enum EventCategory
	{
		None = 0,
		EventCategoryApplication    = BIT(0),
		EventCategoryInput          = BIT(1),
		EventCategoryKeyboard       = BIT(2),
		EventCategoryMouse          = BIT(3),
		EventCategoryMouseButton    = BIT(4)
	};

#define EVENT_CLASS_TYPE(type) static EventType GetStaticType() { return EventType::type; }\
								virtual EventType GetEventType() const override { return GetStaticType(); }\
								virtual const char* GetName() const override { return #type; }

#define EVENT_CLASS_CATEGORY(category) virtual int GetCategoryFlags() const override { return category; }

	class Event
	{
	public:
		virtual ~Event() = default;

		bool Handled = false;

		virtual EventType GetEventType() const = 0;
		virtual const char* GetName() const = 0;
		virtual int GetCategoryFlags() const = 0;
		virtual std::string ToString() const { return GetName(); }

		bool IsInCategory(EventCategory category)
		{
			return GetCategoryFlags() & category;
		}
	};

	class EventDispatcher
	{
	public:
		EventDispatcher(Event& event)
			: m_Event(event)
		{
		}
		
		template<typename T, typename F>
		bool Dispatch(const F& func)
		{
			if (m_Event.GetEventType() == T::GetStaticType())
			{
				m_Event.Handled |= func(static_cast<T&>(m_Event));
				return true;
			}
			return false;
		}
	private:
		Event& m_Event;
	};
}



====================
FILE: ./Aether/src/Aether/Events/KeyEvent.h
====================
#pragma once

#include "Aether/Events/Event.h"
#include "Aether/Core/KeyCodes.h"

namespace Aether {

	class KeyEvent : public Event
	{
	public:
		KeyCode GetKeyCode() const { return m_KeyCode; }

		EVENT_CLASS_CATEGORY(EventCategoryKeyboard | EventCategoryInput)
	protected:
		KeyEvent(const KeyCode keycode)
			: m_KeyCode(keycode) {}

		KeyCode m_KeyCode;
	};

	class KeyPressedEvent : public KeyEvent
	{
	public:
		KeyPressedEvent(const KeyCode keycode, bool isRepeat = false)
			: KeyEvent(keycode), m_IsRepeat(isRepeat) {}

		bool IsRepeat() const { return m_IsRepeat; }

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "KeyPressedEvent: " << m_KeyCode << " (repeat = " << m_IsRepeat << ")";
			return ss.str();
		}

		EVENT_CLASS_TYPE(KeyPressed)
	private:
		bool m_IsRepeat;
	};

	class KeyReleasedEvent : public KeyEvent
	{
	public:
		KeyReleasedEvent(const KeyCode keycode)
			: KeyEvent(keycode) {}

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "KeyReleasedEvent: " << m_KeyCode;
			return ss.str();
		}

		EVENT_CLASS_TYPE(KeyReleased)
	};

	class KeyTypedEvent : public KeyEvent
	{
	public:
		KeyTypedEvent(const KeyCode keycode)
			: KeyEvent(keycode) {}

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "KeyTypedEvent: " << m_KeyCode;
			return ss.str();
		}

		EVENT_CLASS_TYPE(KeyTyped)
	};
}

====================
FILE: ./Aether/src/Aether/Events/ApplicationEvent.h
====================
#pragma once

#include "Aether/Events/Event.h"
#include <sstream>

namespace Aether {

	class WindowResizeEvent : public Event
	{
	public:
		WindowResizeEvent(unsigned int width, unsigned int height)
			: m_Width(width), m_Height(height) {}

		unsigned int GetWidth() const { return m_Width; }
		unsigned int GetHeight() const { return m_Height; }

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "WindowResizeEvent: " << m_Width << ", " << m_Height;
			return ss.str();
		}

		inline friend std::ostream& operator<<(std::ostream& os, const WindowResizeEvent& e)
		{
			return os << e.ToString();
		}

		EVENT_CLASS_TYPE(WindowResize)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	private:
		unsigned int m_Width, m_Height;
	};

	class WindowCloseEvent : public Event
	{
	public:
		WindowCloseEvent() = default;

		EVENT_CLASS_TYPE(WindowClose)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	};

	class AppTickEvent : public Event
	{
	public:
		AppTickEvent() = default;

		EVENT_CLASS_TYPE(AppTick)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	};

	class AppUpdateEvent : public Event
	{
	public:
		AppUpdateEvent() = default;

		EVENT_CLASS_TYPE(AppUpdate)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	};

	class AppRenderEvent : public Event
	{
	public:
		AppRenderEvent() = default;

		EVENT_CLASS_TYPE(AppRender)
		EVENT_CLASS_CATEGORY(EventCategoryApplication)
	};
}


====================
FILE: ./Aether/src/Aether/Events/MouseEvent.h
====================
#pragma once

#include "Aether/Events/Event.h"
#include "Aether/Core/MouseCodes.h"

namespace Aether {

	class MouseMovedEvent : public Event
	{
	public:
		MouseMovedEvent(const float x, const float y)
			: m_MouseX(x), m_MouseY(y) {}

		float GetX() const { return m_MouseX; }
		float GetY() const { return m_MouseY; }

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "MouseMovedEvent: " << m_MouseX << ", " << m_MouseY;
			return ss.str();
		}

		EVENT_CLASS_TYPE(MouseMoved)
		EVENT_CLASS_CATEGORY(EventCategoryMouse | EventCategoryInput)
	private:
		float m_MouseX, m_MouseY;
	};

	class MouseScrolledEvent : public Event
	{
	public:
		MouseScrolledEvent(const float xOffset, const float yOffset)
			: m_XOffset(xOffset), m_YOffset(yOffset) {}

		float GetXOffset() const { return m_XOffset; }
		float GetYOffset() const { return m_YOffset; }

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "MouseScrolledEvent: " << GetXOffset() << ", " << GetYOffset();
			return ss.str();
		}

		EVENT_CLASS_TYPE(MouseScrolled)
		EVENT_CLASS_CATEGORY(EventCategoryMouse | EventCategoryInput)
	private:
		float m_XOffset, m_YOffset;
	};

	class MouseButtonEvent : public Event
	{
	public:
		MouseCode GetMouseButton() const { return m_Button; }

		EVENT_CLASS_CATEGORY(EventCategoryMouse | EventCategoryInput | EventCategoryMouseButton)
	protected:
		MouseButtonEvent(const MouseCode button)
			: m_Button(button) {}

		MouseCode m_Button;
	};

	class MouseButtonPressedEvent : public MouseButtonEvent
	{
	public:
		MouseButtonPressedEvent(const MouseCode button)
			: MouseButtonEvent(button) {}

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "MouseButtonPressedEvent: " << m_Button;
			return ss.str();
		}

		EVENT_CLASS_TYPE(MouseButtonPressed)
	};

	class MouseButtonReleasedEvent : public MouseButtonEvent
	{
	public:
		MouseButtonReleasedEvent(const MouseCode button)
			: MouseButtonEvent(button) {}

		std::string ToString() const override
		{
			std::stringstream ss;
			ss << "MouseButtonReleasedEvent: " << m_Button;
			return ss.str();
		}

		EVENT_CLASS_TYPE(MouseButtonReleased)
	};

}

====================
FILE: ./Sandbox/src/SandboxApp.cpp
====================
#include <Aether.h> 
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/matrix_transform.hpp>

class TestLayer : public Aether::Layer
{
public:
    TestLayer()
        : Layer("Shadow Mapping Demo"), m_Camera(glm::vec3(0.0f, 3.0f, 10.0f))
    {
    }

    virtual ~TestLayer() = default;

    virtual void Detach() override 
    {
        m_VAO.reset();
        m_VBO.reset();
        m_IBO.reset();
        m_Shader.reset();
        m_ShadowShader.reset();
        m_Texture.reset();
        m_ShadowFBO.reset(); 
    }

    virtual void Attach() override 
    {
        // Setup ImGui context
        ImGuiContext* IGContext = Aether::ImGuiLayer::GetContext();
        if (IGContext) ImGui::SetCurrentContext(IGContext);
        
        // Initialize rendering
        Aether::Legacy::LegacyAPI::Init();

        // Create cube geometry (24 vertices, properly indexed)
        float vertices[] = {
            // Positions          // Normals           // TexCoords
            // Back face (Z-)
            -0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 0.0f,
             0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 0.0f,
             0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  1.0f, 1.0f,
            -0.5f,  0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f, 1.0f,
            
            // Front face (Z+)
            -0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  0.0f, 0.0f,
             0.5f, -0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  1.0f, 0.0f,
             0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  1.0f, 1.0f,
            -0.5f,  0.5f,  0.5f,  0.0f,  0.0f,  1.0f,  0.0f, 1.0f,
            
            // Left face (X-)
            -0.5f,  0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 0.0f,
            -0.5f,  0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  1.0f, 1.0f,
            -0.5f, -0.5f, -0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
            -0.5f, -0.5f,  0.5f, -1.0f,  0.0f,  0.0f,  0.0f, 0.0f,
            
            // Right face (X+)
             0.5f,  0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f,
             0.5f,  0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  1.0f, 1.0f,
             0.5f, -0.5f, -0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 1.0f,
             0.5f, -0.5f,  0.5f,  1.0f,  0.0f,  0.0f,  0.0f, 0.0f,
            
            // Bottom face (Y-)
            -0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 1.0f,
             0.5f, -0.5f, -0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 1.0f,
             0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  1.0f, 0.0f,
            -0.5f, -0.5f,  0.5f,  0.0f, -1.0f,  0.0f,  0.0f, 0.0f,
            
            // Top face (Y+)
            -0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 1.0f,
             0.5f,  0.5f, -0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 1.0f,
             0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  1.0f, 0.0f,
            -0.5f,  0.5f,  0.5f,  0.0f,  1.0f,  0.0f,  0.0f, 0.0f
        };

        unsigned int indices[] = {
            0,  1,  2,   2,  3,  0,   // Back face
            4,  5,  6,   6,  7,  4,   // Front face
            8,  9,  10,  10, 11, 8,   // Left face
            12, 13, 14,  14, 15, 12,  // Right face
            16, 17, 18,  18, 19, 16,  // Bottom face
            20, 21, 22,  22, 23, 20   // Top face
        };

        // Setup vertex array and buffers
        m_VAO = std::make_shared<Aether::Legacy::VertexArray>();
        m_VBO = std::make_shared<Aether::Legacy::VertexBuffer>(vertices, sizeof(vertices));
        
        Aether::Legacy::VertexBufferLayout layout;
        layout.Push<float>(3); // Position
        layout.Push<float>(3); // Normal
        layout.Push<float>(2); // TexCoord
        m_VAO->AddBuffer(*m_VBO, layout);

        m_IBO = std::make_shared<Aether::Legacy::IndexBuffer>(indices, 36);
        
        // Load shaders
        AE_CORE_INFO("Loading shaders...");
        m_Shader = std::make_shared<Aether::Legacy::Shader>(
            "/Users/Cyberdemon/Private/Aether/Aether/src/Platform/LegacyOpenGL/res/shaders/LightingShadow.shader"
        );
        m_ShadowShader = std::make_shared<Aether::Legacy::Shader>(
            "/Users/Cyberdemon/Private/Aether/Aether/src/Platform/LegacyOpenGL/res/shaders/ShadowMap.shader"
        );
        AE_CORE_INFO("Shaders loaded successfully");
        
        // Load texture
        m_Texture = std::make_shared<Aether::Legacy::Texture>(
            "/Users/Cyberdemon/Private/Aether/Aether/src/Platform/LegacyOpenGL/res/textures/wood.jpg"
        );

        // Create shadow map framebuffer
        Aether::Legacy::FramebufferSpecification fbSpec;
        fbSpec.Width = m_ShadowMapResolution; 
        fbSpec.Height = m_ShadowMapResolution;
        fbSpec.Attachments = { Aether::Legacy::FramebufferTextureFormat::DEPTH24STENCIL8 };
        
        m_ShadowFBO = std::make_shared<Aether::Legacy::FrameBuffer>(fbSpec);
        
        AE_CORE_INFO("Shadow framebuffer created - Depth Attachment ID: {0}", 
                     m_ShadowFBO->GetDepthAttachmentRendererID());
        
        AE_INFO("Shadow Mapping Demo initialized successfully!");
        AE_INFO("Controls: Click to lock cursor, WASD to move, Space/Ctrl for up/down, ESC to unlock");
    }

    void Update(Aether::Timestep ts) override
    {
        // Update rotation
        if (m_EnableRotation) {
            m_Rotation += ts * m_RotationSpeed;
        }

        // Get window dimensions
        auto& window = Aether::Application::Get().GetWindow();
        uint32_t windowWidth = window.GetWidth();
        uint32_t windowHeight = window.GetHeight();

        // Handle input
        HandleInput(ts);

        // Calculate light space matrix for shadow mapping
        glm::mat4 lightSpaceMatrix = CalculateLightSpaceMatrix();

        // ========== PASS 1: SHADOW MAP GENERATION ==========
        RenderShadowPass(lightSpaceMatrix);

        // ========== PASS 2: MAIN SCENE RENDERING ==========
        RenderMainPass(windowWidth, windowHeight, lightSpaceMatrix);
    }

    void HandleInput(Aether::Timestep ts)
    {
        // Toggle cursor lock with ESC
        if (Aether::Input::IsKeyPressed(Aether::Key::Escape)) {
            m_CursorLocked = false;
            Aether::Input::SetCursorMode(Aether::CursorMode::Normal);
        }
        
        // Lock cursor on left click (if not over ImGui)
        if (Aether::Input::IsMouseButtonPressed(Aether::Mouse::ButtonLeft) && 
            !m_CursorLocked && !ImGui::GetIO().WantCaptureMouse) {
            m_CursorLocked = true;
            Aether::Input::SetCursorMode(Aether::CursorMode::Locked);
            m_LastMousePos = Aether::Input::GetMousePosition();
        }
        
        // Camera movement when cursor is locked
        if (m_CursorLocked) {
            // Keyboard movement
            if (Aether::Input::IsKeyPressed(Aether::Key::W)) 
                m_Camera.ProcessKeyboard(Aether::Legacy::FORWARD, ts);
            if (Aether::Input::IsKeyPressed(Aether::Key::S)) 
                m_Camera.ProcessKeyboard(Aether::Legacy::BACKWARD, ts);
            if (Aether::Input::IsKeyPressed(Aether::Key::A)) 
                m_Camera.ProcessKeyboard(Aether::Legacy::LEFT, ts);
            if (Aether::Input::IsKeyPressed(Aether::Key::D)) 
                m_Camera.ProcessKeyboard(Aether::Legacy::RIGHT, ts);
            if (Aether::Input::IsKeyPressed(Aether::Key::Space)) 
                m_Camera.ProcessKeyboard(Aether::Legacy::UP, ts);
            if (Aether::Input::IsKeyPressed(Aether::Key::LeftControl)) 
                m_Camera.ProcessKeyboard(Aether::Legacy::DOWN, ts);
            
            // Mouse look
            glm::vec2 currentMousePos = Aether::Input::GetMousePosition();
            glm::vec2 delta = currentMousePos - m_LastMousePos;
            m_LastMousePos = currentMousePos;
            m_Camera.ProcessMouseMovement(delta.x, -delta.y);
        }
    }

    glm::mat4 CalculateLightSpaceMatrix()
    {
        float near_plane = 1.0f, far_plane = 30.0f;
        glm::mat4 lightProjection = glm::ortho(
            -m_LightFrustumSize, m_LightFrustumSize, 
            -m_LightFrustumSize, m_LightFrustumSize, 
            near_plane, far_plane
        );
        glm::mat4 lightView = glm::lookAt(
            m_LightPos, 
            glm::vec3(0.0f), 
            glm::vec3(0.0f, 1.0f, 0.0f)
        );
        return lightProjection * lightView;
    }

    void RenderShadowPass(const glm::mat4& lightSpaceMatrix)
    {
        // Bind shadow framebuffer
        m_ShadowFBO->Bind();
        Aether::Legacy::LegacyAPI::SetViewport(0, 0, m_ShadowMapResolution, m_ShadowMapResolution);
        Aether::Legacy::LegacyAPI::Clear();
        
        // Bind shadow shader and set uniforms
        m_ShadowShader->Bind();
        m_ShadowShader->SetUniformMat4f("u_LightSpaceMatrix", lightSpaceMatrix);
        
        // Render scene from light's perspective
        RenderScene(m_ShadowShader);
        
        // Unbind shadow framebuffer
        m_ShadowFBO->Unbind();
    }

    void RenderMainPass(uint32_t width, uint32_t height, const glm::mat4& lightSpaceMatrix)
    {
        // Set viewport to window size
        Aether::Legacy::LegacyAPI::SetViewport(0, 0, width, height);
        
        // Clear screen with background color
        Aether::Legacy::LegacyAPI::SetClearColor(m_BackgroundColor);
        Aether::Legacy::LegacyAPI::Clear();

        // Bind main shader
        m_Shader->Bind();
        
        // Bind textures
        m_Texture->Bind(0);
        m_Shader->SetUniform1i("u_Texture", 0);
        
        m_ShadowFBO->BindDepthTexture(1);
        m_Shader->SetUniform1i("u_ShadowMap", 1);

        // Set camera matrices
        float aspectRatio = (float)width / (float)height;
        glm::mat4 projection = glm::perspective(
            glm::radians(m_Camera.Zoom), 
            aspectRatio, 
            0.1f, 
            100.0f
        );
        glm::mat4 view = m_Camera.GetViewMatrix();
        
        // Set shader uniforms
        m_Shader->SetUniformMat4f("u_Projection", projection);
        m_Shader->SetUniformMat4f("u_View", view);
        m_Shader->SetUniform3f("u_ViewPos", m_Camera.Position);
        m_Shader->SetUniform3f("u_LightPos", m_LightPos);
        m_Shader->SetUniformMat4f("u_LightSpaceMatrix", lightSpaceMatrix);

        // Render scene from camera's perspective
        RenderScene(m_Shader);
    }

    void RenderScene(std::shared_ptr<Aether::Legacy::Shader> shader)
    {
        // Render Cube A (rotating)
        glm::mat4 model = glm::translate(glm::mat4(1.0f), m_TranslationA);
        model = glm::rotate(model, m_Rotation, glm::vec3(0.5f, 1.0f, 0.0f));
        model = glm::scale(model, glm::vec3(m_CubeScale));
        shader->SetUniformMat4f("u_Model", model);
        Aether::Legacy::LegacyAPI::Draw(*m_VAO, *m_IBO, *shader);

        // Render Cube B (rotating in different direction)
        model = glm::translate(glm::mat4(1.0f), m_TranslationB);
        model = glm::rotate(model, m_Rotation * 0.7f, glm::vec3(1.0f, 0.5f, 0.0f));
        model = glm::scale(model, glm::vec3(m_CubeScale));
        shader->SetUniformMat4f("u_Model", model);
        Aether::Legacy::LegacyAPI::Draw(*m_VAO, *m_IBO, *shader);
        
        // Render floor plane
        model = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, -2.0f, 0.0f));
        model = glm::scale(model, glm::vec3(m_FloorScale, 0.1f, m_FloorScale));
        shader->SetUniformMat4f("u_Model", model);
        Aether::Legacy::LegacyAPI::Draw(*m_VAO, *m_IBO, *shader);
    }

    virtual void OnImGuiRender() override
    {
        ImGui::Begin("Shadow Mapping Controls");
        
        // FPS and Camera Info
        ImGui::Text("FPS: %.1f (%.3f ms)", ImGui::GetIO().Framerate, 1000.0f / ImGui::GetIO().Framerate);
        ImGui::Text("Camera Position: (%.1f, %.1f, %.1f)", 
            m_Camera.Position.x, m_Camera.Position.y, m_Camera.Position.z);
        ImGui::Separator();
        
        // Camera Controls
        if (ImGui::CollapsingHeader("Camera", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::TextColored(ImVec4(0.5f, 1.0f, 0.5f, 1.0f), "Controls:");
            ImGui::BulletText("Left Click: Lock/Unlock cursor");
            ImGui::BulletText("WASD: Move horizontally");
            ImGui::BulletText("Space/Ctrl: Move up/down");
            ImGui::BulletText("Mouse: Look around");
            ImGui::BulletText("ESC: Unlock cursor");
            ImGui::Spacing();
            ImGui::SliderFloat("Movement Speed", &m_Camera.MovementSpeed, 1.0f, 20.0f);
            ImGui::SliderFloat("Mouse Sensitivity", &m_Camera.MouseSensitivity, 0.05f, 0.5f);
            ImGui::SliderFloat("FOV (Zoom)", &m_Camera.Zoom, 30.0f, 120.0f);
        }
        
        // Lighting Controls
        if (ImGui::CollapsingHeader("Lighting", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::SliderFloat3("Light Position", &m_LightPos.x, -15.0f, 15.0f);
            ImGui::SliderFloat("Light Frustum Size", &m_LightFrustumSize, 5.0f, 30.0f);
            ImGui::Separator();
            ImGui::Text("Shadow Map Settings:");
            if (ImGui::SliderInt("Shadow Resolution", &m_ShadowMapResolution, 512, 4096)) {
                // Recreate shadow framebuffer with new resolution
                Aether::Legacy::FramebufferSpecification fbSpec;
                fbSpec.Width = m_ShadowMapResolution;
                fbSpec.Height = m_ShadowMapResolution;
                fbSpec.Attachments = { Aether::Legacy::FramebufferTextureFormat::DEPTH24STENCIL8 };
                m_ShadowFBO = std::make_shared<Aether::Legacy::FrameBuffer>(fbSpec);
            }
        }
        
        // Scene Objects
        if (ImGui::CollapsingHeader("Scene Objects", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::Text("Cube A:");
            ImGui::SliderFloat3("Position##CubeA", &m_TranslationA.x, -8.0f, 8.0f);
            ImGui::Spacing();
            
            ImGui::Text("Cube B:");
            ImGui::SliderFloat3("Position##CubeB", &m_TranslationB.x, -8.0f, 8.0f);
            ImGui::Spacing();
            
            ImGui::SliderFloat("Cube Scale", &m_CubeScale, 0.5f, 3.0f);
            ImGui::SliderFloat("Floor Scale", &m_FloorScale, 5.0f, 30.0f);
        }
        
        // Animation
        if (ImGui::CollapsingHeader("Animation")) {
            ImGui::Checkbox("Enable Rotation", &m_EnableRotation);
            ImGui::SliderFloat("Rotation Speed", &m_RotationSpeed, 0.0f, 2.0f);
            if (ImGui::Button("Reset Rotation")) {
                m_Rotation = 0.0f;
            }
        }
        
        // Rendering Settings
        if (ImGui::CollapsingHeader("Rendering")) {
            ImGui::ColorEdit3("Background Color", &m_BackgroundColor.x);
        }
        
        ImGui::End();
    }

    void OnEvent(Aether::Event& event) override 
    {
        // Handle events if needed
    }

private:
    // Rendering resources
    std::shared_ptr<Aether::Legacy::VertexArray> m_VAO;
    std::shared_ptr<Aether::Legacy::VertexBuffer> m_VBO;
    std::shared_ptr<Aether::Legacy::IndexBuffer> m_IBO;
    std::shared_ptr<Aether::Legacy::Shader> m_Shader;
    std::shared_ptr<Aether::Legacy::Shader> m_ShadowShader;
    std::shared_ptr<Aether::Legacy::Texture> m_Texture;
    std::shared_ptr<Aether::Legacy::FrameBuffer> m_ShadowFBO;
    
    // Camera
    Aether::Legacy::Camera m_Camera;
    bool m_CursorLocked = false;
    glm::vec2 m_LastMousePos = { 0.0f, 0.0f };
    
    // Scene objects
    glm::vec3 m_TranslationA = { -2.0f, 0.5f, 0.0f };
    glm::vec3 m_TranslationB = { 2.0f, 0.5f, 0.0f };
    float m_CubeScale = 1.0f;
    float m_FloorScale = 15.0f;
    
    // Lighting
    glm::vec3 m_LightPos = { -5.0f, 8.0f, -3.0f };
    float m_LightFrustumSize = 15.0f;
    
    // Animation
    float m_Rotation = 0.0f;
    float m_RotationSpeed = 0.5f;
    bool m_EnableRotation = true;
    
    // Rendering settings
    glm::vec4 m_BackgroundColor = { 0.2f, 0.3f, 0.4f, 1.0f };
    int m_ShadowMapResolution = 2048;
};


class Sandbox : public Aether::Application
{
public:
    Sandbox()
    {
        PushLayer(new TestLayer());
    }

    ~Sandbox()
    {
    }
};

Aether::Application* Aether::CreateApplication()
{
    return new Sandbox();
}